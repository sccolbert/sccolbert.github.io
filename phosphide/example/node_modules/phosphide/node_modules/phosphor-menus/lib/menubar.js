/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var phosphor_domutil_1 = require('phosphor-domutil');
var helpers_1 = require('./helpers');
var menubase_1 = require('./menubase');
var menuitem_1 = require('./menuitem');
/**
 * The class name added to a menu bar widget.
 */
var MENU_BAR_CLASS = 'p-MenuBar';
/**
 * The class name added to a menu bar content node.
 */
var CONTENT_CLASS = 'p-MenuBar-content';
/**
 * The class name added to an open menu bar menu.
 */
var MENU_CLASS = 'p-MenuBar-menu';
/**
 * The class name added to a menu bar item node.
 */
var ITEM_CLASS = 'p-MenuBar-item';
/**
 * The class name added to a menu bar item icon cell.
 */
var ICON_CLASS = 'p-MenuBar-item-icon';
/**
 * The class name added to a menu bar item text cell.
 */
var TEXT_CLASS = 'p-MenuBar-item-text';
/**
 * The class name added to a separator menu bar item.
 */
var SEPARATOR_TYPE_CLASS = 'p-mod-separator-type';
/**
 * The class name added to an active menu bar and item.
 */
var ACTIVE_CLASS = 'p-mod-active';
/**
 * The class name added to a disabled menu bar item.
 */
var DISABLED_CLASS = 'p-mod-disabled';
/**
 * The class name added to a hidden menu bar item.
 */
var HIDDEN_CLASS = 'p-mod-hidden';
/**
 * A widget which displays menu items as a menu bar.
 */
var MenuBar = (function (_super) {
    __extends(MenuBar, _super);
    /**
     * Construct a new menu bar.
     */
    function MenuBar() {
        _super.call(this);
        this._active = false;
        this._childMenu = null;
        this._nodes = [];
        this.addClass(MENU_BAR_CLASS);
    }
    /**
     * Create the DOM node for a menu bar.
     */
    MenuBar.createNode = function () {
        var node = document.createElement('div');
        var content = document.createElement('ul');
        content.className = CONTENT_CLASS;
        node.appendChild(content);
        return node;
    };
    /**
     * A convenience method to create a menu bar from a template.
     *
     * @param array - The menu item templates for the menu bar.
     *
     * @returns A new menu bar created from the menu item templates.
     */
    MenuBar.fromTemplate = function (array) {
        var items = array.map(function (tmpl) { return menuitem_1.MenuItem.fromTemplate(tmpl); });
        var bar = new MenuBar();
        bar.items = items;
        return bar;
    };
    /**
     * Dispose of the resources held by the menu bar.
     */
    MenuBar.prototype.dispose = function () {
        this._reset();
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(MenuBar.prototype, "childMenu", {
        /**
         * Get the child menu of the menu bar.
         *
         * #### Notes
         * This will be `null` if the menu bar does not have an open menu.
         */
        get: function () {
            return this._childMenu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MenuBar.prototype, "contentNode", {
        /**
         * Get the menu bar content node.
         *
         * #### Notes
         * This is the node which holds the menu item nodes. Modifying the
         * content of this node without care can lead to undesired behavior.
         */
        get: function () {
            return this.node.getElementsByClassName(CONTENT_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handle the DOM events for the menu bar.
     *
     * @param event - The DOM event sent to the menu bar.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the menu bar's DOM nodes. It
     * should not be called directly by user code.
     */
    MenuBar.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'mousemove':
                this._evtMouseMove(event);
                break;
            case 'mouseleave':
                this._evtMouseLeave(event);
                break;
            case 'contextmenu':
                this._evtContextMenu(event);
                break;
            case 'keydown':
                this._evtKeyDown(event);
                break;
            case 'keypress':
                this._evtKeyPress(event);
                break;
        }
    };
    /**
     * A method invoked when the menu items change.
     */
    MenuBar.prototype.onItemsChanged = function (old, items) {
        // Reset the menu bar before updating the items.
        this._reset();
        // Disconnect the old item signals.
        for (var i = 0, n = old.length; i < n; ++i) {
            if (items.indexOf(old[i]) === -1) {
                old[i].changed.disconnect(this._onItemChanged, this);
            }
        }
        // Connect the new item signals.
        for (var i = 0, n = items.length; i < n; ++i) {
            if (old.indexOf(items[i]) === -1) {
                items[i].changed.connect(this._onItemChanged, this);
            }
        }
        // Schedulte an update of the DOM content.
        this.update();
    };
    /**
     * A method invoked when the active index changes.
     */
    MenuBar.prototype.onActiveIndexChanged = function (old, index) {
        var oldNode = this._nodes[old];
        var newNode = this._nodes[index];
        if (oldNode)
            oldNode.classList.remove(ACTIVE_CLASS);
        if (newNode)
            newNode.classList.add(ACTIVE_CLASS);
    };
    /**
     * A method invoked when a menu item should be opened.
     */
    MenuBar.prototype.onOpenItem = function (index, item) {
        if (this.isAttached) {
            var ref = this._nodes[index] || this.node;
            this._activate();
            this._closeChildMenu();
            this._openChildMenu(item.submenu, ref);
        }
    };
    /**
     * A message handler invoked on a `'close-request'` message.
     */
    MenuBar.prototype.onCloseRequest = function (msg) {
        this._reset();
        _super.prototype.onCloseRequest.call(this, msg);
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    MenuBar.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('mousedown', this);
        this.node.addEventListener('mousemove', this);
        this.node.addEventListener('mouseleave', this);
        this.node.addEventListener('contextmenu', this);
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    MenuBar.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('mousedown', this);
        this.node.removeEventListener('mousemove', this);
        this.node.removeEventListener('mouseleave', this);
        this.node.removeEventListener('contextmenu', this);
    };
    /**
     * A handler invoked on an `'update-request'` message.
     */
    MenuBar.prototype.onUpdateRequest = function (msg) {
        // Fetch common variables.
        var items = this.items;
        var nodes = this._nodes;
        var index = this.activeIndex;
        var content = this.contentNode;
        // Remove any excess item nodes.
        while (nodes.length > items.length) {
            var node = nodes.pop();
            content.removeChild(node);
        }
        // Add any missing item nodes.
        while (nodes.length < items.length) {
            var node = createItemNode();
            nodes.push(node);
            content.appendChild(node);
        }
        // Update the node state to match the menu items.
        for (var i = 0, n = items.length; i < n; ++i) {
            updateItemNode(items[i], nodes[i]);
            if (i === index) {
                nodes[i].classList.add(ACTIVE_CLASS);
            }
            else {
                nodes[i].classList.remove(ACTIVE_CLASS);
            }
        }
        // Collapse the neighboring separators.
        helpers_1.collapseSeparators(items, nodes);
    };
    /**
     * Handle the `'mousedown'` event for the menu bar.
     */
    MenuBar.prototype._evtMouseDown = function (event) {
        var x = event.clientX;
        var y = event.clientY;
        // If the bar is active and the mouse press is on an open menu,
        // let that menu handle the press. The bar will reset when the
        // menu emits its `closed` signal.
        if (this._active && hitTestMenus(this._childMenu, x, y)) {
            return;
        }
        // Check if the mouse was pressed on one of the menu items.
        var i = hitTestNodes(this._nodes, x, y);
        // If the bar is active, deactivate it and close the child menu.
        // The active index is updated to reflect the mouse press, which
        // is either valid, or `-1`.
        if (this._active) {
            this._deactivate();
            this._closeChildMenu();
            this.activeIndex = i;
            return;
        }
        // At this point, the bar is not active. If the mouse press
        // was not on a menu item, clear the active index and return.
        if (i === -1) {
            this.activeIndex = -1;
            return;
        }
        // Otherwise, the press was on a menu item. Activate the bar,
        // update the active index, and open the menu item if possible.
        this._activate();
        this.activeIndex = i;
        this.openActiveItem();
    };
    /**
     * Handle the `'mousemove'` event for the menu bar.
     */
    MenuBar.prototype._evtMouseMove = function (event) {
        var x = event.clientX;
        var y = event.clientY;
        // Check if the mouse is over one of the menu items.
        var i = hitTestNodes(this._nodes, x, y);
        // Bail early if the active index will not change.
        if (i === this.activeIndex) {
            return;
        }
        // Bail early if the bar is active and the mouse is not over an
        // item. This allows the leading and trailing menus to be kept
        // open when the mouse is over the empty part of the menu bar.
        if (i === -1 && this._active) {
            return;
        }
        // Update the active index to the hovered item.
        this.activeIndex = i;
        // If the bar is not active, there's nothing more to do.
        if (!this._active) {
            return;
        }
        // Otherwise, close the current child menu and open the new one.
        this._closeChildMenu();
        this.openActiveItem();
    };
    /**
     * Handle the `'mouseleave'` event for the menu bar.
     */
    MenuBar.prototype._evtMouseLeave = function (event) {
        if (!this._active)
            this.activeIndex = -1;
    };
    /**
     * Handle the `'contextmenu'` event for the menu bar.
     */
    MenuBar.prototype._evtContextMenu = function (event) {
        event.preventDefault();
        event.stopPropagation();
    };
    /**
     * Handle the `'keydown'` event for the menu bar.
     */
    MenuBar.prototype._evtKeyDown = function (event) {
        event.stopPropagation();
        var menu = this._childMenu;
        var leaf = menu && menu.leafMenu;
        switch (event.keyCode) {
            case 13:
                event.preventDefault();
                if (leaf)
                    leaf.triggerActiveItem();
                break;
            case 27:
                event.preventDefault();
                if (leaf)
                    leaf.close();
                break;
            case 37:
                event.preventDefault();
                if (leaf && leaf !== menu) {
                    leaf.close();
                }
                else {
                    this._closeChildMenu();
                    this.activatePreviousItem();
                    this.openActiveItem();
                }
                break;
            case 38:
                event.preventDefault();
                if (leaf)
                    leaf.activatePreviousItem();
                break;
            case 39:
                event.preventDefault();
                if (leaf && activeHasMenu(leaf)) {
                    leaf.openActiveItem();
                }
                else {
                    this._closeChildMenu();
                    this.activateNextItem();
                    this.openActiveItem();
                }
                break;
            case 40:
                event.preventDefault();
                if (leaf)
                    leaf.activateNextItem();
                break;
        }
    };
    /**
     * Handle the `'keypress'` event for the menu bar.
     */
    MenuBar.prototype._evtKeyPress = function (event) {
        event.preventDefault();
        event.stopPropagation();
        var menu = this._childMenu;
        var leaf = menu && menu.leafMenu;
        var key = String.fromCharCode(event.charCode);
        (leaf || this).activateMnemonicItem(key);
    };
    /**
     * Open the child menu using the given item node for location.
     */
    MenuBar.prototype._openChildMenu = function (menu, node) {
        var rect = node.getBoundingClientRect();
        this._childMenu = menu;
        menu.addClass(MENU_CLASS);
        menu.open(rect.left, rect.bottom, false, true);
        menu.closed.connect(this._onMenuClosed, this);
    };
    /**
     * Close the current child menu, if one exists.
     */
    MenuBar.prototype._closeChildMenu = function () {
        var menu = this._childMenu;
        if (menu) {
            this._childMenu = null;
            menu.closed.disconnect(this._onMenuClosed, this);
            menu.removeClass(MENU_CLASS);
            menu.close();
        }
    };
    /**
     * Activate the menu bar and switch the mouse listeners to global.
     *
     * The listeners are switched after the current event dispatch is
     * complete. Otherwise, duplicate event notifications could occur.
     */
    MenuBar.prototype._activate = function () {
        var _this = this;
        if (this._active) {
            return;
        }
        this._active = true;
        this.addClass(ACTIVE_CLASS);
        setTimeout(function () {
            _this.node.removeEventListener('mousedown', _this);
            document.addEventListener('mousedown', _this, true);
            document.addEventListener('keydown', _this, true);
            document.addEventListener('keypress', _this, true);
        }, 0);
    };
    /**
     * Deactivate the menu bar switch the mouse listeners to local.
     *
     * The listeners are switched after the current event dispatch is
     * complete. Otherwise, duplicate event notifications could occur.
     */
    MenuBar.prototype._deactivate = function () {
        var _this = this;
        if (!this._active) {
            return;
        }
        this._active = false;
        this.removeClass(ACTIVE_CLASS);
        setTimeout(function () {
            _this.node.addEventListener('mousedown', _this);
            document.removeEventListener('mousedown', _this, true);
            document.removeEventListener('keydown', _this, true);
            document.removeEventListener('keypress', _this, true);
        }, 0);
    };
    /**
     * Reset the menu bar to its default state.
     */
    MenuBar.prototype._reset = function () {
        this._deactivate();
        this._closeChildMenu();
        this.activeIndex = -1;
    };
    /**
     * Handle the `changed` signal from a menu item.
     */
    MenuBar.prototype._onItemChanged = function (sender, args) {
        this.update();
    };
    /**
     * Handle the `closed` signal from the child menu.
     */
    MenuBar.prototype._onMenuClosed = function (sender) {
        sender.closed.disconnect(this._onMenuClosed, this);
        sender.removeClass(MENU_CLASS);
        this._childMenu = null;
        this._reset();
    };
    return MenuBar;
})(menubase_1.MenuBase);
exports.MenuBar = MenuBar;
/**
 * Create an uninitialized DOM node for a MenuItem.
 */
function createItemNode() {
    var node = document.createElement('li');
    var icon = document.createElement('span');
    var text = document.createElement('span');
    text.className = TEXT_CLASS;
    node.appendChild(icon);
    node.appendChild(text);
    return node;
}
/**
 * Create the complete DOM node class name for a MenuItem.
 */
function createItemClass(item) {
    var parts = [ITEM_CLASS];
    if (item.isSeparatorType) {
        parts.push(SEPARATOR_TYPE_CLASS);
    }
    if (item.disabled) {
        parts.push(DISABLED_CLASS);
    }
    if (item.hidden) {
        parts.push(HIDDEN_CLASS);
    }
    if (item.className) {
        parts.push(item.className);
    }
    return parts.join(' ');
}
/**
 * Create the icon node class name for a MenuItem.
 */
function createIconClass(item) {
    return item.icon ? (ICON_CLASS + ' ' + item.icon) : ICON_CLASS;
}
/**
 * Create the text node content for a MenuItem.
 */
function createTextContent(item) {
    return item.isSeparatorType ? '' : item.text.replace(/&/g, '');
}
/**
 * Update the node state for a MenuItem.
 */
function updateItemNode(item, node) {
    var icon = node.firstChild;
    var text = node.lastChild;
    node.className = createItemClass(item);
    icon.className = createIconClass(item);
    text.textContent = createTextContent(item);
}
/**
 * Test whether a menu's active item has a submenu.
 */
function activeHasMenu(menu) {
    var item = menu.items[menu.activeIndex];
    return !!(item && item.submenu);
}
/**
 * Get the index of the node at a client position, or `-1`.
 */
function hitTestNodes(nodes, x, y) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
        if (phosphor_domutil_1.hitTest(nodes[i], x, y))
            return i;
    }
    return -1;
}
/**
 * Hit test the chain menus for the given client position.
 */
function hitTestMenus(menu, x, y) {
    while (menu) {
        if (phosphor_domutil_1.hitTest(menu.node, x, y)) {
            return true;
        }
        menu = menu.childMenu;
    }
    return false;
}
//# sourceMappingURL=menubar.js.map