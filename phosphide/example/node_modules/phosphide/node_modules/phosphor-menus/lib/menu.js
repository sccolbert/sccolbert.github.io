/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var phosphor_domutil_1 = require('phosphor-domutil');
var phosphor_messaging_1 = require('phosphor-messaging');
var phosphor_signaling_1 = require('phosphor-signaling');
var phosphor_widget_1 = require('phosphor-widget');
var helpers_1 = require('./helpers');
var menubase_1 = require('./menubase');
var menuitem_1 = require('./menuitem');
/**
 * The class name added to Menu instances.
 */
var MENU_CLASS = 'p-Menu';
/**
 * The class name added to a menu content node.
 */
var CONTENT_CLASS = 'p-Menu-content';
/**
 * The class name added to a menu item node.
 */
var ITEM_CLASS = 'p-Menu-item';
/**
 * The class name added to a menu item icon cell.
 */
var ICON_CLASS = 'p-Menu-item-icon';
/**
 * The class name added to a menu item text cell.
 */
var TEXT_CLASS = 'p-Menu-item-text';
/**
 * The class name added to a menu item shortcut cell.
 */
var SHORTCUT_CLASS = 'p-Menu-item-shortcut';
/**
 * The class name added to a menu item submenu cell.
 */
var SUBMENU_CLASS = 'p-Menu-item-submenu';
/**
 * The class name added to a check type menu item.
 */
var CHECK_TYPE_CLASS = 'p-mod-check-type';
/**
 * The class name added to a separator type menu item.
 */
var SEPARATOR_TYPE_CLASS = 'p-mod-separator-type';
/**
 * The class name added to active menu items.
 */
var ACTIVE_CLASS = 'p-mod-active';
/**
 * The class name added to a disabled menu item.
 */
var DISABLED_CLASS = 'p-mod-disabled';
/**
 * The class name added to a hidden menu item.
 */
var HIDDEN_CLASS = 'p-mod-hidden';
/**
 * The class name added to a checked menu item.
 */
var CHECKED_CLASS = 'p-mod-checked';
/**
 * The class name added to a menu item with a submenu.
 */
var HAS_SUBMENU_CLASS = 'p-mod-has-submenu';
/**
 * The ms delay for opening a submenu.
 */
var OPEN_DELAY = 300;
/**
 * The ms delay for closing a submenu.
 */
var CLOSE_DELAY = 300;
/**
 * The horizontal px overlap for open submenus.
 */
var SUBMENU_OVERLAP = 3;
/**
 * A widget which displays menu items as a popup menu.
 */
var Menu = (function (_super) {
    __extends(Menu, _super);
    /**
     * Construct a new menu.
     */
    function Menu() {
        _super.call(this);
        this._openTimerId = 0;
        this._closeTimerId = 0;
        this._parentMenu = null;
        this._childMenu = null;
        this._childItem = null;
        this._nodes = [];
        this.addClass(MENU_CLASS);
    }
    /**
     * Create the DOM node for a menu.
     */
    Menu.createNode = function () {
        var node = document.createElement('div');
        var content = document.createElement('ul');
        content.className = CONTENT_CLASS;
        node.appendChild(content);
        return node;
    };
    /**
     * A convenience method to create a menu from a template.
     *
     * @param array - The menu item templates for the menu.
     *
     * @returns A new menu created from the menu item templates.
     */
    Menu.fromTemplate = function (array) {
        var items = array.map(function (tmpl) { return menuitem_1.MenuItem.fromTemplate(tmpl); });
        var menu = new Menu();
        menu.items = items;
        return menu;
    };
    /**
     * Dispose of the resources held by the menu.
     */
    Menu.prototype.dispose = function () {
        this.close();
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(Menu.prototype, "closed", {
        /**
         * A signal emitted when the menu item is closed.
         *
         * #### Notes
         * This is a pure delegate to the [[closedSignal]].
         */
        get: function () {
            return Menu.closedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "parentMenu", {
        /**
         * Get the parent menu of the menu.
         *
         * #### Notes
         * This will be null if the menu is not an open submenu.
         */
        get: function () {
            return this._parentMenu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "childMenu", {
        /**
         * Get the child menu of the menu.
         *
         * #### Notes
         * This will be null if the menu does not have an open submenu.
         */
        get: function () {
            return this._childMenu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "rootMenu", {
        /**
         * Find the root menu of this menu hierarchy.
         */
        get: function () {
            var menu = this;
            while (menu._parentMenu) {
                menu = menu._parentMenu;
            }
            return menu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "leafMenu", {
        /**
         * Find the leaf menu of this menu hierarchy.
         */
        get: function () {
            var menu = this;
            while (menu._childMenu) {
                menu = menu._childMenu;
            }
            return menu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "contentNode", {
        /**
         * Get the menu content node.
         *
         * #### Notes
         * This is the node which holds the menu item nodes. Modifying the
         * content of this node without care can lead to undesired behavior.
         */
        get: function () {
            return this.node.getElementsByClassName(CONTENT_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Popup the menu at the specified location.
     *
     * The menu will be opened at the given location unless it will not
     * fully fit on the screen. If it will not fit, it will be adjusted
     * to fit naturally on the screen. The last two optional parameters
     * control whether the provided coordinate value must be obeyed.
     *
     * When the menu is opened as a popup menu, it will handle all key
     * events related to menu navigation as well as closing the menu
     * when the mouse is pressed outside of the menu hierarchy. To
     * prevent these actions, use the `open` method instead.
     *
     * @param x - The client X coordinate of the popup location.
     *
     * @param y - The client Y coordinate of the popup location.
     *
     * @param forceX - Whether the X coordinate must be obeyed.
     *
     * @param forceY - Whether the Y coordinate must be obeyed.
     *
     * **See also:** [[open]]
     */
    Menu.prototype.popup = function (x, y, forceX, forceY) {
        if (forceX === void 0) { forceX = false; }
        if (forceY === void 0) { forceY = false; }
        if (!this.isAttached) {
            document.addEventListener('keydown', this, true);
            document.addEventListener('keypress', this, true);
            document.addEventListener('mousedown', this, true);
            openRootMenu(this, x, y, forceX, forceY);
        }
    };
    /**
     * Open the menu at the specified location.
     *
     * The menu will be opened at the given location unless it will not
     * fully fit on the screen. If it will not fit, it will be adjusted
     * to fit naturally on the screen. The last two optional parameters
     * control whether the provided coordinate value must be obeyed.
     *
     * When the menu is opened with this method, it will not handle key
     * events for navigation, nor will it close itself when the mouse is
     * pressed outside the menu hierarchy. This is useful when using the
     * menu from a menubar, where this menubar should handle these tasks.
     * Use the `popup` method for the alternative behavior.
     *
     * @param x - The client X coordinate of the popup location.
     *
     * @param y - The client Y coordinate of the popup location.
     *
     * @param forceX - Whether the X coordinate must be obeyed.
     *
     * @param forceY - Whether the Y coordinate must be obeyed.
     *
     * **See also:** [[popup]]
     */
    Menu.prototype.open = function (x, y, forceX, forceY) {
        if (forceX === void 0) { forceX = false; }
        if (forceY === void 0) { forceY = false; }
        if (!this.isAttached) {
            openRootMenu(this, x, y, forceX, forceY);
        }
    };
    /**
     * Handle the DOM events for the menu.
     *
     * @param event - The DOM event sent to the menu.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the menu's DOM nodes. It should
     * not be called directly by user code.
     */
    Menu.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'mouseenter':
                this._evtMouseEnter(event);
                break;
            case 'mouseleave':
                this._evtMouseLeave(event);
                break;
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'mouseup':
                this._evtMouseUp(event);
                break;
            case 'contextmenu':
                this._evtContextMenu(event);
                break;
            case 'keydown':
                this._evtKeyDown(event);
                break;
            case 'keypress':
                this._evtKeyPress(event);
                break;
        }
    };
    /**
     * A method invoked when the menu items change.
     */
    Menu.prototype.onItemsChanged = function (old, items) {
        this.close();
    };
    /**
     * A method invoked when the active index changes.
     */
    Menu.prototype.onActiveIndexChanged = function (old, index) {
        var oldNode = this._nodes[old];
        var newNode = this._nodes[index];
        if (oldNode)
            oldNode.classList.remove(ACTIVE_CLASS);
        if (newNode)
            newNode.classList.add(ACTIVE_CLASS);
    };
    /**
     * A method invoked when a menu item should be opened.
     */
    Menu.prototype.onOpenItem = function (index, item) {
        if (this.isAttached) {
            var ref = this._nodes[index] || this.node;
            this._openChildMenu(item, ref, false);
            this._childMenu.activateNextItem();
        }
    };
    /**
     * A method invoked when a menu item should be triggered.
     */
    Menu.prototype.onTriggerItem = function (index, item) {
        this.rootMenu.close();
        var handler = item.handler;
        if (handler)
            handler(item);
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    Menu.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('mouseup', this);
        this.node.addEventListener('mouseleave', this);
        this.node.addEventListener('contextmenu', this);
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    Menu.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('mouseup', this);
        this.node.removeEventListener('mouseleave', this);
        this.node.removeEventListener('contextmenu', this);
        document.removeEventListener('keydown', this, true);
        document.removeEventListener('keypress', this, true);
        document.removeEventListener('mousedown', this, true);
    };
    /**
     * A handler invoked on an `'update-request'` message.
     */
    Menu.prototype.onUpdateRequest = function (msg) {
        // Fetch common variables.
        var items = this.items;
        var nodes = this._nodes;
        var index = this.activeIndex;
        var content = this.contentNode;
        // Remove any excess item nodes.
        while (nodes.length > items.length) {
            var node = nodes.pop();
            content.removeChild(node);
        }
        // Add any missing item nodes.
        while (nodes.length < items.length) {
            var node = createItemNode();
            nodes.push(node);
            content.appendChild(node);
            node.addEventListener('mouseenter', this);
        }
        // Update the node state to match the menu items.
        for (var i = 0, n = items.length; i < n; ++i) {
            updateItemNode(items[i], nodes[i]);
            if (i === index) {
                nodes[i].classList.add(ACTIVE_CLASS);
            }
            else {
                nodes[i].classList.remove(ACTIVE_CLASS);
            }
        }
        // Collapse the neighboring separators.
        helpers_1.collapseSeparators(items, nodes);
    };
    /**
     * A message handler invoked on a `'close-request'` message.
     */
    Menu.prototype.onCloseRequest = function (msg) {
        // Reset the menu state.
        this._cancelPendingOpen();
        this._cancelPendingClose();
        this.activeIndex = -1;
        // Close any open child menu.
        var childMenu = this._childMenu;
        if (childMenu) {
            this._childMenu = null;
            this._childItem = null;
            childMenu._parentMenu = null;
            childMenu.close();
        }
        // Remove this menu from any parent.
        var parentMenu = this._parentMenu;
        if (parentMenu) {
            this._parentMenu = null;
            parentMenu._cancelPendingOpen();
            parentMenu._cancelPendingClose();
            parentMenu._childMenu = null;
            parentMenu._childItem = null;
        }
        // Ensure this menu is detached.
        if (this.parent) {
            this.parent = null;
            this.closed.emit(void 0);
        }
        else if (this.isAttached) {
            phosphor_widget_1.Widget.detach(this);
            this.closed.emit(void 0);
        }
    };
    /**
     * Handle the `'mouseenter'` event for a menu item.
     */
    Menu.prototype._evtMouseEnter = function (event) {
        this._syncAncestors();
        this._closeChildMenu();
        this._cancelPendingOpen();
        var node = event.currentTarget;
        this.activeIndex = this._nodes.indexOf(node);
        var item = this.items[this.activeIndex];
        if (item && item.submenu) {
            if (item === this._childItem) {
                this._cancelPendingClose();
            }
            else {
                this._openChildMenu(item, node, true);
            }
        }
    };
    /**
     * Handle the `'mouseleave'` event for the menu.
     */
    Menu.prototype._evtMouseLeave = function (event) {
        this._cancelPendingOpen();
        var child = this._childMenu;
        if (!child || !phosphor_domutil_1.hitTest(child.node, event.clientX, event.clientY)) {
            this.activeIndex = -1;
            this._closeChildMenu();
        }
    };
    /**
     * Handle the `'mouseup'` event for the menu.
     */
    Menu.prototype._evtMouseUp = function (event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.button !== 0) {
            return;
        }
        var node = this._nodes[this.activeIndex];
        if (node && node.contains(event.target)) {
            this.triggerActiveItem();
        }
    };
    /**
     * Handle the `'contextmenu'` event for the menu bar.
     */
    Menu.prototype._evtContextMenu = function (event) {
        event.preventDefault();
        event.stopPropagation();
    };
    /**
     * Handle the `'mousedown'` event for the menu.
     *
     * This event listener is attached to the document for a popup menu.
     */
    Menu.prototype._evtMouseDown = function (event) {
        var menu = this;
        var hit = false;
        var x = event.clientX;
        var y = event.clientY;
        while (!hit && menu) {
            hit = phosphor_domutil_1.hitTest(menu.node, x, y);
            menu = menu._childMenu;
        }
        if (!hit)
            this.close();
    };
    /**
     * Handle the `'keydown'` event for the menu.
     *
     * This event listener is attached to the document for a popup menu.
     */
    Menu.prototype._evtKeyDown = function (event) {
        event.stopPropagation();
        var leaf = this.leafMenu;
        switch (event.keyCode) {
            case 13:
                event.preventDefault();
                leaf.triggerActiveItem();
                break;
            case 27:
                event.preventDefault();
                leaf.close();
                break;
            case 37:
                event.preventDefault();
                if (leaf !== this)
                    leaf.close();
                break;
            case 38:
                event.preventDefault();
                leaf.activatePreviousItem();
                break;
            case 39:
                event.preventDefault();
                leaf.openActiveItem();
                break;
            case 40:
                event.preventDefault();
                leaf.activateNextItem();
                break;
        }
    };
    /**
     * Handle the `'keypress'` event for the menu.
     *
     * This event listener is attached to the document for a popup menu.
     */
    Menu.prototype._evtKeyPress = function (event) {
        event.preventDefault();
        event.stopPropagation();
        var key = String.fromCharCode(event.charCode);
        this.leafMenu.activateMnemonicItem(key);
    };
    /**
     * Synchronize the active item hierarchy starting with the parent.
     *
     * This ensures that the proper child items are activated for the
     * ancestor menu hierarchy and that any pending open or close tasks
     * are canceled.
     */
    Menu.prototype._syncAncestors = function () {
        var menu = this._parentMenu;
        while (menu) {
            menu._syncChildItem();
            menu = menu._parentMenu;
        }
    };
    /**
     * Synchronize the active index with the current child item.
     */
    Menu.prototype._syncChildItem = function () {
        this._cancelPendingOpen();
        this._cancelPendingClose();
        this.activeIndex = this.items.indexOf(this._childItem);
    };
    /**
     * Open the menu item's submenu using the node for location.
     *
     * If the given item is already open, this is a no-op.
     *
     * Any pending open operation will be canceled before opening the
     * menu or queuing the delayed task to open the menu.
     */
    Menu.prototype._openChildMenu = function (item, node, delayed) {
        var _this = this;
        if (item === this._childItem) {
            return;
        }
        this._cancelPendingOpen();
        if (delayed) {
            this._openTimerId = setTimeout(function () {
                var menu = item.submenu;
                _this._openTimerId = 0;
                _this._childItem = item;
                _this._childMenu = menu;
                menu._parentMenu = _this;
                openSubmenu(menu, node);
            }, OPEN_DELAY);
        }
        else {
            var menu = item.submenu;
            this._childItem = item;
            this._childMenu = menu;
            menu._parentMenu = this;
            openSubmenu(menu, node);
        }
    };
    /**
     * Close the currently open child menu using a delayed task.
     *
     * If a task is pending or if there is no child menu, this is a no-op.
     */
    Menu.prototype._closeChildMenu = function () {
        var _this = this;
        if (this._closeTimerId || !this._childMenu) {
            return;
        }
        this._closeTimerId = setTimeout(function () {
            _this._closeTimerId = 0;
            var childMenu = _this._childMenu;
            if (childMenu) {
                _this._childMenu = null;
                _this._childItem = null;
                childMenu._parentMenu = null;
                childMenu.close();
            }
        }, CLOSE_DELAY);
    };
    /**
     * Cancel any pending child menu open task.
     */
    Menu.prototype._cancelPendingOpen = function () {
        if (this._openTimerId) {
            clearTimeout(this._openTimerId);
            this._openTimerId = 0;
        }
    };
    /**
     * Cancel any pending child menu close task.
     */
    Menu.prototype._cancelPendingClose = function () {
        if (this._closeTimerId) {
            clearTimeout(this._closeTimerId);
            this._closeTimerId = 0;
        }
    };
    /**
     * A signal emitted when the menu is closed.
     *
     * **See also:** [[closed]]
     */
    Menu.closedSignal = new phosphor_signaling_1.Signal();
    return Menu;
})(menubase_1.MenuBase);
exports.Menu = Menu;
/**
 * Create an uninitialized DOM node for a MenuItem.
 */
function createItemNode() {
    var node = document.createElement('li');
    var icon = document.createElement('span');
    var text = document.createElement('span');
    var shortcut = document.createElement('span');
    var submenu = document.createElement('span');
    text.className = TEXT_CLASS;
    shortcut.className = SHORTCUT_CLASS;
    submenu.className = SUBMENU_CLASS;
    node.appendChild(icon);
    node.appendChild(text);
    node.appendChild(shortcut);
    node.appendChild(submenu);
    return node;
}
/**
 * Create the complete DOM node class name for a MenuItem.
 */
function createItemClass(item) {
    var parts = [ITEM_CLASS];
    if (item.isCheckType) {
        parts.push(CHECK_TYPE_CLASS);
    }
    else if (item.isSeparatorType) {
        parts.push(SEPARATOR_TYPE_CLASS);
    }
    if (item.checked) {
        parts.push(CHECKED_CLASS);
    }
    if (item.disabled) {
        parts.push(DISABLED_CLASS);
    }
    if (item.hidden) {
        parts.push(HIDDEN_CLASS);
    }
    if (item.submenu) {
        parts.push(HAS_SUBMENU_CLASS);
    }
    if (item.className) {
        parts.push(item.className);
    }
    return parts.join(' ');
}
/**
 * Create the icon node class name for a MenuItem.
 */
function createIconClass(item) {
    return item.icon ? (ICON_CLASS + ' ' + item.icon) : ICON_CLASS;
}
/**
 * Create the text node content for a MenuItem.
 */
function createTextContent(item) {
    return item.isSeparatorType ? '' : item.text.replace(/&/g, '');
}
/**
 * Create the shortcut text for a MenuItem.
 */
function createShortcutText(item) {
    return item.isSeparatorType ? '' : item.shortcut;
}
/**
 * Update the node state for a MenuItem.
 */
function updateItemNode(item, node) {
    var icon = node.children[0];
    var text = node.children[1];
    var shortcut = node.children[2];
    node.className = createItemClass(item);
    icon.className = createIconClass(item);
    text.textContent = createTextContent(item);
    shortcut.textContent = createShortcutText(item);
}
/**
 * Get the currently visible viewport rect in page coordinates.
 */
function clientViewportRect() {
    var elem = document.documentElement;
    var x = window.pageXOffset;
    var y = window.pageYOffset;
    var width = elem.clientWidth;
    var height = elem.clientHeight;
    return { x: x, y: y, width: width, height: height };
}
/**
 * Mount the menu as hidden and compute its optimal size.
 *
 * If the vertical scrollbar becomes visible, the menu will be expanded
 * by the scrollbar width to prevent clipping the contents of the menu.
 */
function mountAndMeasure(menu, maxHeight) {
    var node = menu.node;
    var style = node.style;
    style.top = '';
    style.left = '';
    style.width = '';
    style.height = '';
    style.visibility = 'hidden';
    style.maxHeight = maxHeight + 'px';
    phosphor_widget_1.Widget.attach(menu, document.body);
    if (node.scrollHeight > maxHeight) {
        style.width = 2 * node.offsetWidth - node.clientWidth + 'px';
    }
    var rect = node.getBoundingClientRect();
    return { width: rect.width, height: rect.height };
}
/**
 * Show the menu at the specified position.
 */
function showMenu(menu, x, y) {
    var style = menu.node.style;
    style.top = Math.max(0, y) + 'px';
    style.left = Math.max(0, x) + 'px';
    style.visibility = '';
}
/**
 * Open the menu as a root menu at the target location.
 */
function openRootMenu(menu, x, y, forceX, forceY) {
    phosphor_messaging_1.sendMessage(menu, phosphor_widget_1.Widget.MsgUpdateRequest);
    var rect = clientViewportRect();
    var size = mountAndMeasure(menu, rect.height - (forceY ? y : 0));
    if (!forceX && (x + size.width > rect.x + rect.width)) {
        x = rect.x + rect.width - size.width;
    }
    if (!forceY && (y + size.height > rect.y + rect.height)) {
        if (y > rect.y + rect.height) {
            y = rect.y + rect.height - size.height;
        }
        else {
            y = y - size.height;
        }
    }
    showMenu(menu, x, y);
}
/**
 * Open a the menu as a submenu using the item node for positioning.
 */
function openSubmenu(menu, item) {
    phosphor_messaging_1.sendMessage(menu, phosphor_widget_1.Widget.MsgUpdateRequest);
    var rect = clientViewportRect();
    var size = mountAndMeasure(menu, rect.height);
    var box = phosphor_domutil_1.boxSizing(menu.node);
    var itemRect = item.getBoundingClientRect();
    var x = itemRect.right - SUBMENU_OVERLAP;
    var y = itemRect.top - box.borderTop - box.paddingTop;
    if (x + size.width > rect.x + rect.width) {
        x = itemRect.left + SUBMENU_OVERLAP - size.width;
    }
    if (y + size.height > rect.y + rect.height) {
        y = itemRect.bottom + box.borderBottom + box.paddingBottom - size.height;
    }
    showMenu(menu, x, y);
}
//# sourceMappingURL=menu.js.map