/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var phosphor_boxpanel_1 = require('phosphor-boxpanel');
var phosphor_stackedpanel_1 = require('phosphor-stackedpanel');
var tabbar_1 = require('./tabbar');
/**
 * The class name added to TabPanel instances.
 */
var TAB_PANEL_CLASS = 'p-TabPanel';
/**
 * A panel which combines a `TabBar` and a `StackedPanel`.
 *
 * #### Notes
 * Children for this panel should be added to the [[widgets]] list.
 */
var TabPanel = (function (_super) {
    __extends(TabPanel, _super);
    /**
     * Construct a new tab panel.
     */
    function TabPanel() {
        _super.call(this);
        this.addClass(TAB_PANEL_CLASS);
        var ctor = this.constructor;
        this._tabs = ctor.createTabBar();
        this._stack = ctor.createStackedPanel();
        this._tabs.items = this._stack.children;
        this._tabs.currentItemChanged.connect(this.onCurrentItemChanged, this);
        this._tabs.itemCloseRequested.connect(this.onItemCloseRequested, this);
        phosphor_boxpanel_1.BoxPanel.setStretch(this._tabs, 0);
        phosphor_boxpanel_1.BoxPanel.setStretch(this._stack, 1);
        this.direction = phosphor_boxpanel_1.BoxPanel.TopToBottom;
        this.spacing = 0;
        this.children.add(this._tabs);
        this.children.add(this._stack);
    }
    /**
     * Create the `TabBar` for the tab panel.
     *
     * @returns The tab bar to use with the tab panel.
     *
     * #### Notes
     * This may be reimplemented by a subclass to create a custom
     * tab bar for use with the tab panel.
     */
    TabPanel.createTabBar = function () {
        return new tabbar_1.TabBar();
    };
    /**
     * Create the `StackedPanel` for the tab panel.
     *
     * @returns The stacked panel to use with the tab panel.
     *
     * #### Notes
     * This may be reimplemented by a subclass to create a custom
     * stacked panel for use with the tab panel.
     */
    TabPanel.createStackedPanel = function () {
        return new phosphor_stackedpanel_1.StackedPanel();
    };
    /**
     * Dispose of the resources held by the widget.
     */
    TabPanel.prototype.dispose = function () {
        this._tabs = null;
        this._stack = null;
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(TabPanel.prototype, "currentWidget", {
        /**
         * Get the currently selected widget.
         *
         * #### Notes
         * This is a convenience alias to the `currentItem` property of the
         * tab bar.
         */
        get: function () {
            return this._tabs.currentItem;
        },
        /**
         * Set the currently selected widget.
         *
         * #### Notes
         * This is a convenience alias to the `currentItem` property of the
         * tab bar.
         */
        set: function (widget) {
            this._tabs.currentItem = widget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabPanel.prototype, "tabsMovable", {
        /**
         * Get whether the tabs are movable by the user.
         *
         * #### Notes
         * This is a convenience alias to the `tabsMovable` property of the
         * tab bar.
         */
        get: function () {
            return this._tabs.tabsMovable;
        },
        /**
         * Set whether the tabs are movable by the user.
         *
         * #### Notes
         * This is a convenience alias to the `tabsMovable` property of the
         * tab bar.
         */
        set: function (movable) {
            this._tabs.tabsMovable = movable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabPanel.prototype, "widgets", {
        /**
         * Get the observable list of widgets for the tab panel.
         *
         * #### Notes
         * Widgets to arrange in the tab panel should be added to this list.
         *
         * This is a read-only alias of the `children` property of the
         * stacked panel.
         */
        get: function () {
            return this._stack.children;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabPanel.prototype, "tabs", {
        /**
         * Get the tab bar associated with the tab panel.
         *
         * #### Notes
         * The items in the tab bar are automatically synchronized with the
         * children of the stacked panel.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._tabs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabPanel.prototype, "stack", {
        /**
         * Get the stacked panel associated with the tab panel.
         *
         * #### Notes
         * The children of the stacked panel are automatically synchronized
         * with the items in the tab bar.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._stack;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handle the `currentItemChanged` signal from the tab bar.
     *
     * #### Notes
     * This can be reimplemented by subclasses as needed.
     *
     * The default implementation of this method synchronizes the current
     * tab item with current widget of the stacked panel.
     */
    TabPanel.prototype.onCurrentItemChanged = function (sender, args) {
        this._stack.currentWidget = args.newValue;
    };
    /**
     * Handle the `itemCloseRequested` signal from the tab bar.
     *
     * #### Notes
     * This can be reimplemented by subclasses as needed.
     *
     * The default implementation of this method closes the widget if the
     * widget's title object has its `closable` flag set to `true`.
     */
    TabPanel.prototype.onItemCloseRequested = function (sender, args) {
        if (args.title.closable)
            args.close();
    };
    return TabPanel;
})(phosphor_boxpanel_1.BoxPanel);
exports.TabPanel = TabPanel;
//# sourceMappingURL=tabpanel.js.map