/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var arrays = require('phosphor-arrays');
var phosphor_domutil_1 = require('phosphor-domutil');
var phosphor_messaging_1 = require('phosphor-messaging');
var phosphor_nodewrapper_1 = require('phosphor-nodewrapper');
var phosphor_observablelist_1 = require('phosphor-observablelist');
var phosphor_properties_1 = require('phosphor-properties');
var phosphor_signaling_1 = require('phosphor-signaling');
var phosphor_widget_1 = require('phosphor-widget');
/**
 * The class name added to TabBar instances.
 */
var TAB_BAR_CLASS = 'p-TabBar';
/**
 * The class name added to the tab bar header node.
 */
var HEADER_CLASS = 'p-TabBar-header';
/**
 * The class name added to the tab bar body node.
 */
var BODY_CLASS = 'p-TabBar-body';
/**
 * The class name added to the tab bar content node.
 */
var CONTENT_CLASS = 'p-TabBar-content';
/**
 * The class name added to the tab bar footer node.
 */
var FOOTER_CLASS = 'p-TabBar-footer';
/**
 * The class name added to Tab instances.
 */
var TAB_CLASS = 'p-Tab';
/**
 * The class name added to a tab text node.
 */
var TEXT_CLASS = 'p-Tab-text';
/**
 * The class name added to a tab icon node.
 */
var ICON_CLASS = 'p-Tab-icon';
/**
 * The class name added to a tab close node.
 */
var CLOSE_CLASS = 'p-Tab-close';
/**
 * The class name added to a tab bar and tab when dragging.
 */
var DRAGGING_CLASS = 'p-mod-dragging';
/**
 * The class name added to the current tab.
 */
var CURRENT_CLASS = 'p-mod-current';
/**
 * The class name added to a closable tab.
 */
var CLOSABLE_CLASS = 'p-mod-closable';
/**
 * A class name added to the first tab in the tab bar.
 */
var FIRST_CLASS = 'p-mod-first';
/**
 * A class name added to the last tab in the tab bar.
 */
var LAST_CLASS = 'p-mod-last';
/**
 * The start drag distance threshold.
 */
var DRAG_THRESHOLD = 5;
/**
 * The tear-off distance threshold.
 */
var TEAR_OFF_THRESHOLD = 20;
/**
 * The tab transition duration.
 */
var TRANSITION_DURATION = 150; // Keep in sync with CSS.
/**
 * A widget which displays a list of tab items as a row of tabs.
 */
var TabBar = (function (_super) {
    __extends(TabBar, _super);
    /**
     * Construct a new tab bar.
     */
    function TabBar() {
        _super.call(this);
        this._tabs = [];
        this._dragData = null;
        this.addClass(TAB_BAR_CLASS);
    }
    /**
     * Create the DOM node for a tab bar.
     */
    TabBar.createNode = function () {
        var node = document.createElement('div');
        var header = document.createElement('div');
        var body = document.createElement('div');
        var content = document.createElement('ul');
        var footer = document.createElement('div');
        header.className = HEADER_CLASS;
        body.className = BODY_CLASS;
        content.className = CONTENT_CLASS;
        footer.className = FOOTER_CLASS;
        body.appendChild(content);
        node.appendChild(header);
        node.appendChild(body);
        node.appendChild(footer);
        return node;
    };
    /**
     * Dispose of the resources held by the widget.
     */
    TabBar.prototype.dispose = function () {
        this._releaseMouse();
        this._tabs.forEach(function (tab) { tab.dispose(); });
        this._tabs.length = 0;
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(TabBar.prototype, "itemCloseRequested", {
        /**
         * A signal emitted when the user clicks a tab item's close icon.
         *
         * #### Notes
         * This is a pure delegate to the [[itemCloseRequestedSignal]].
         */
        get: function () {
            return TabBar.itemCloseRequestedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "currentItem", {
        /**
         * Get the currently selected tab item.
         *
         * #### Notes
         * This is a pure delegate to the [[currentItemProperty]].
         */
        get: function () {
            return TabBar.currentItemProperty.get(this);
        },
        /**
         * Set the currently selected tab item.
         *
         * #### Notes
         * This is a pure delegate to the [[currentItemProperty]].
         */
        set: function (value) {
            TabBar.currentItemProperty.set(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "currentItemChanged", {
        /**
         * A signal emitted when the current tab item is changed.
         *
         * #### Notes
         * This is the notify signal for the [[currentItemProperty]].
         */
        get: function () {
            return TabBar.currentItemProperty.notify.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "items", {
        /**
         * Get the list of tab items for the tab bar.
         *
         * #### Notes
         * This is a pure delegate to the [[itemsProperty]].
         */
        get: function () {
            return TabBar.itemsProperty.get(this);
        },
        /**
         * Set the list tab items for the tab bar.
         *
         * #### Notes
         * This is a pure delegate to the [[itemsProperty]].
         */
        set: function (value) {
            TabBar.itemsProperty.set(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "tabsMovable", {
        /**
         * Get whether the tabs are movable by the user.
         *
         * #### Notes
         * This is a pure delegate to the [[tabsMovableProperty]].
         */
        get: function () {
            return TabBar.tabsMovableProperty.get(this);
        },
        /**
         * Set whether the tabs are movable by the user.
         *
         * #### Notes
         * This is a pure delegate to the [[tabsMovableProperty]].
         */
        set: function (value) {
            TabBar.tabsMovableProperty.set(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "headerNode", {
        /**
         * Get the tab bar header node.
         *
         * #### Notes
         * This can be used to add extra header content.
         */
        get: function () {
            return this.node.getElementsByClassName(HEADER_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "bodyNode", {
        /**
         * Get the tab bar body node.
         *
         * #### Notes
         * This can be used to add extra body content.
         */
        get: function () {
            return this.node.getElementsByClassName(BODY_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "contentNode", {
        /**
         * Get the tab bar content node.
         *
         * #### Notes
         * This is the node which holds the tab nodes. Modifying the content
         * of this node indiscriminately can lead to undesired behavior.
         */
        get: function () {
            return this.node.getElementsByClassName(CONTENT_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "footerNode", {
        /**
         * Get the tab bar footer node.
         *
         * #### Notes
         * This can be used to add extra footer content.
         */
        get: function () {
            return this.node.getElementsByClassName(FOOTER_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Release the mouse and restore the non-dragged tab positions.
     *
     * #### Notes
     * This will cause the tab bar to stop handling mouse events and to
     * restore the tabs to their non-dragged positions. It is intended
     * to be called when implementing tear off tabs.
     *
     * **See also:** [[onTearOffRequest]]
     */
    TabBar.prototype.releaseMouse = function () {
        this._releaseMouse();
    };
    /**
     * Handle the DOM events for the tab bar.
     *
     * @param event - The DOM event sent to the tab bar.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the tab bar's DOM node. It should
     * not be called directly by user code.
     */
    TabBar.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'click':
                this._evtClick(event);
                break;
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'mousemove':
                this._evtMouseMove(event);
                break;
            case 'mouseup':
                this._evtMouseUp(event);
                break;
        }
    };
    /**
     * Process a message sent to the tab bar.
     *
     * @param msg - The message sent to the tab bar.
     *
     * #### Notes
     * Subclasses may reimplement this method as needed.
     */
    TabBar.prototype.processMessage = function (msg) {
        if (msg.type === 'tear-off-request') {
            this.onTearOffRequest(msg);
        }
        else {
            _super.prototype.processMessage.call(this, msg);
        }
    };
    /**
     * A message handler invoked on a `'tear-off-request'` message.
     *
     * #### Notes
     * This may be reimplemented by subclasses to support tear-off tabs.
     *
     * The reimplementation should take whatever action is necessary for
     * its use case to continue the drag from the given client position.
     * This will typically involve creating a new DOM node to represent
     * the drag item, and may or may not include removing the specified
     * item from the tab bar.
     *
     * If the reimplementation handles the tear-off, it should call the
     * [[releaseMouse]] method so that the tab bar ceases its handling
     * of mouse events.
     *
     * The default implementation of this handler is a no-op.
     */
    TabBar.prototype.onTearOffRequest = function (msg) { };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    TabBar.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('click', this);
        this.node.addEventListener('mousedown', this);
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    TabBar.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('click', this);
        this.node.removeEventListener('mousedown', this);
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     *
     * This handler updates the flex order and z-index of the tabs.
     */
    TabBar.prototype.onUpdateRequest = function (msg) {
        for (var i = 0, n = this._tabs.length, k = n - 1; i < n; ++i) {
            var tab = this._tabs[i];
            var style = tab.node.style;
            if (tab.hasClass(CURRENT_CLASS)) {
                style.zIndex = n + '';
            }
            else {
                style.zIndex = k-- + '';
            }
            style.order = i + '';
            tab.toggleClass(FIRST_CLASS, i === 0);
            tab.toggleClass(LAST_CLASS, i === n - 1);
        }
    };
    /**
     * Handle the `'click'` event for the tab bar.
     */
    TabBar.prototype._evtClick = function (event) {
        // Do nothing if it's not a left click.
        if (event.button !== 0) {
            return;
        }
        // Do nothing if the click is not on a tab.
        var index = hitTestTabs(this._tabs, event.clientX, event.clientY);
        if (index < 0) {
            return;
        }
        // Clicking on a tab stops the event propagation.
        event.preventDefault();
        event.stopPropagation();
        // Emit the close requested signal if the close icon was clicked.
        var tab = this._tabs[index];
        if (tab.closeNode.contains(event.target)) {
            this.itemCloseRequested.emit(tab.item);
        }
    };
    /**
     * Handle the `'mousedown'` event for the tab bar.
     */
    TabBar.prototype._evtMouseDown = function (event) {
        // Do nothing if it's not a left mouse press.
        if (event.button !== 0) {
            return;
        }
        // Bail if a previous drag is still transitioning.
        if (this._dragData) {
            return;
        }
        // Do nothing if the press is not on a tab.
        var index = hitTestTabs(this._tabs, event.clientX, event.clientY);
        if (index < 0) {
            return;
        }
        // Pressing on a tab stops the event propagation.
        event.preventDefault();
        event.stopPropagation();
        // Do nothing if the press was on a close icon node.
        var tab = this._tabs[index];
        if (tab.closeNode.contains(event.target)) {
            return;
        }
        // Setup the drag if the tabs are movable.
        if (this.tabsMovable) {
            var tabRect = tab.node.getBoundingClientRect();
            var data = this._dragData = new DragData();
            data.tab = tab;
            data.tabIndex = index;
            data.tabLeft = tab.node.offsetLeft;
            data.tabWidth = tabRect.width;
            data.pressX = event.clientX;
            data.pressY = event.clientY;
            data.tabPressX = event.clientX - tabRect.left;
            document.addEventListener('mouseup', this, true);
            document.addEventListener('mousemove', this, true);
        }
        // Update the current item to the pressed item.
        this.currentItem = tab.item;
    };
    /**
     * Handle the `'mousemove'` event for the tab bar.
     */
    TabBar.prototype._evtMouseMove = function (event) {
        // Mouse move events are never propagated since this handler
        // is only installed when during a left mouse drag operation.
        event.preventDefault();
        event.stopPropagation();
        // Bail if there is no drag in progress.
        var data = this._dragData;
        if (!data) {
            return;
        }
        // Check to see if the drag threshold has been exceeded, and
        // start the tab drag operation the first time that occurs.
        if (!data.dragActive) {
            var dx = Math.abs(event.clientX - data.pressX);
            var dy = Math.abs(event.clientY - data.pressY);
            if (dx < DRAG_THRESHOLD && dy < DRAG_THRESHOLD) {
                return;
            }
            // Fill in the remaining drag data.
            data.contentRect = this.contentNode.getBoundingClientRect();
            data.tabLayout = snapTabLayout(this._tabs);
            data.cursorGrab = phosphor_domutil_1.overrideCursor('default');
            data.dragActive = true;
            // Add the dragging style classes.
            data.tab.addClass(DRAGGING_CLASS);
            this.addClass(DRAGGING_CLASS);
        }
        // Check to see if the tear-off threshold has been exceeded.
        if (!data.tearOffRequested && tearOffExceeded(data.contentRect, event)) {
            // Only make the tear-off request once per drag action.
            data.tearOffRequested = true;
            // Send the tear-off request message to the tab bar.
            var item = data.tab.item;
            var node = data.tab.node;
            var clientX = event.clientX;
            var clientY = event.clientY;
            phosphor_messaging_1.sendMessage(this, new TearOffMessage(item, node, clientX, clientY));
            // Do nothing further if the mouse has been released.
            if (!this._dragData) {
                return;
            }
        }
        // Compute the target bounds of the drag tab.
        var offsetLeft = event.clientX - data.contentRect.left;
        var targetLeft = offsetLeft - data.tabPressX;
        var targetRight = targetLeft + data.tabWidth;
        // Reset the target tab index.
        data.tabTargetIndex = data.tabIndex;
        // Update the non-drag tab positions and the tab target index.
        var tabs = this._tabs;
        for (var i = 0, n = tabs.length; i < n; ++i) {
            var style = tabs[i].node.style;
            var layout = data.tabLayout[i];
            var threshold = layout.left + (layout.width >> 1);
            if (i < data.tabIndex && targetLeft < threshold) {
                style.left = data.tabWidth + data.tabLayout[i + 1].margin + 'px';
                data.tabTargetIndex = Math.min(data.tabTargetIndex, i);
            }
            else if (i > data.tabIndex && targetRight > threshold) {
                style.left = -data.tabWidth - layout.margin + 'px';
                data.tabTargetIndex = i;
            }
            else if (i !== data.tabIndex) {
                style.left = '';
            }
        }
        // Update the drag tab position.
        var idealLeft = event.clientX - data.pressX;
        var maxLeft = data.contentRect.width - (data.tabLeft + data.tabWidth);
        var adjustedLeft = Math.max(-data.tabLeft, Math.min(idealLeft, maxLeft));
        data.tab.node.style.left = adjustedLeft + 'px';
    };
    /**
     * Handle the `'mouseup'` event for the tab bar.
     */
    TabBar.prototype._evtMouseUp = function (event) {
        var _this = this;
        // Do nothing if the left mouse button is not released.
        if (event.button !== 0) {
            return;
        }
        // Mouse up events are never propagated since this handler
        // is only installed when during a left mouse drag operation.
        event.preventDefault();
        event.stopPropagation();
        // Bail if there is no drag in progress.
        var data = this._dragData;
        if (!data) {
            return;
        }
        // Remove the extra mouse handlers.
        document.removeEventListener('mouseup', this, true);
        document.removeEventListener('mousemove', this, true);
        // If the drag is not active, clear the reference and bail.
        if (!data.dragActive) {
            this._dragData = null;
            return;
        }
        // Compute the approximate final relative tab offset.
        var idealLeft;
        if (data.tabTargetIndex === data.tabIndex) {
            idealLeft = 0;
        }
        else if (data.tabTargetIndex > data.tabIndex) {
            var tl = data.tabLayout[data.tabTargetIndex];
            idealLeft = tl.left + tl.width - data.tabWidth - data.tabLeft;
        }
        else {
            var tl = data.tabLayout[data.tabTargetIndex];
            idealLeft = tl.left - data.tabLeft;
        }
        // Position the tab to its final position, subject to limits.
        var maxLeft = data.contentRect.width - (data.tabLeft + data.tabWidth);
        var adjustedLeft = Math.max(-data.tabLeft, Math.min(idealLeft, maxLeft));
        data.tab.node.style.left = adjustedLeft + 'px';
        // Remove the dragging class from the tab so it can be transitioned.
        data.tab.removeClass(DRAGGING_CLASS);
        // Complete the release on a timer to allow the tab to transition.
        setTimeout(function () {
            // Bail if the drag data has been changed or released.
            if (_this._dragData !== data) {
                return;
            }
            // Clear the drag data reference.
            _this._dragData = null;
            // Clear the relative tab positions.
            for (var i = 0, n = _this._tabs.length; i < n; ++i) {
                _this._tabs[i].node.style.left = '';
            }
            // Clear the cursor grab and drag styles.
            data.cursorGrab.dispose();
            _this.removeClass(DRAGGING_CLASS);
            // Finally, move the tab item to the new location.
            var fromIndex = data.tabIndex;
            var toIndex = data.tabTargetIndex;
            if (toIndex !== -1 && fromIndex !== toIndex) {
                _this.items.move(fromIndex, toIndex);
                // Force an update to prevent flicker on IE.
                phosphor_messaging_1.sendMessage(_this, phosphor_widget_1.Widget.MsgUpdateRequest);
            }
        }, TRANSITION_DURATION);
    };
    /**
     * Release the mouse and restore the non-dragged tab positions.
     */
    TabBar.prototype._releaseMouse = function () {
        // Bail early if there is no drag in progress.
        var data = this._dragData;
        if (!data) {
            return;
        }
        // Clear the drag data reference.
        this._dragData = null;
        // Remove the extra mouse listeners.
        document.removeEventListener('mouseup', this, true);
        document.removeEventListener('mousemove', this, true);
        // If the drag is not active, there's nothing left to do.
        if (!data.dragActive) {
            return;
        }
        // Reset the positions of the tabs.
        for (var i = 0, n = this._tabs.length; i < n; ++i) {
            this._tabs[i].node.style.left = '';
        }
        // Clear the cursor grab and drag styles.
        data.cursorGrab.dispose();
        data.tab.removeClass(DRAGGING_CLASS);
        this.removeClass(DRAGGING_CLASS);
    };
    /**
     * The coerce handler for the [[currentItemProperty]].
     */
    TabBar.prototype._coerceCurrentItem = function (item) {
        var list = this.items;
        return (item && list && list.contains(item)) ? item : null;
    };
    /**
     * The change handler for the [[currentItemProperty]].
     */
    TabBar.prototype._onCurrentItemChanged = function (oldItem, newItem) {
        var oldTab = arrays.find(this._tabs, function (tab) { return tab.item === oldItem; });
        var newTab = arrays.find(this._tabs, function (tab) { return tab.item === newItem; });
        if (oldTab)
            oldTab.removeClass(CURRENT_CLASS);
        if (newTab)
            newTab.addClass(CURRENT_CLASS);
        this.update();
    };
    /**
     * The change handler for the [[itemsProperty]].
     */
    TabBar.prototype._onItemsChanged = function (oldList, newList) {
        // Ensure the mouse is released.
        this._releaseMouse();
        // Disconnect the old list and dispose the old tabs.
        if (oldList) {
            oldList.changed.disconnect(this._onItemsListChanged, this);
            var content = this.contentNode;
            while (this._tabs.length) {
                var tab = this._tabs.pop();
                content.removeChild(tab.node);
                tab.dispose();
            }
        }
        // Create the new tabs and connect the new list.
        if (newList) {
            var content = this.contentNode;
            for (var i = 0, n = newList.length; i < n; ++i) {
                var tab = new Tab(newList.get(i));
                content.appendChild(tab.node);
                this._tabs.push(tab);
            }
            newList.changed.connect(this._onItemsListChanged, this);
        }
        // Update the current item.
        this.currentItem = newList && newList.get(0);
        // Update the tab node order.
        this.update();
    };
    /**
     * The change handler for the items list `changed` signal.
     */
    TabBar.prototype._onItemsListChanged = function (sender, args) {
        switch (args.type) {
            case phosphor_observablelist_1.ListChangeType.Add:
                this._onItemsListAdd(args);
                break;
            case phosphor_observablelist_1.ListChangeType.Move:
                this._onItemsListMove(args);
                break;
            case phosphor_observablelist_1.ListChangeType.Remove:
                this._onItemsListRemove(args);
                break;
            case phosphor_observablelist_1.ListChangeType.Replace:
                this._onItemsListReplace(args);
                break;
            case phosphor_observablelist_1.ListChangeType.Set:
                this._onItemsListSet(args);
                break;
        }
    };
    /**
     * The handler invoked on a items list change of type `Add`.
     */
    TabBar.prototype._onItemsListAdd = function (args) {
        // Ensure the mouse is released.
        this._releaseMouse();
        // Create the tab for the new tab item.
        var tab = new Tab(args.newValue);
        // Add the tab to the same location in the internal array.
        arrays.insert(this._tabs, args.newIndex, tab);
        // Add the tab node to the DOM. The position is irrelevant.
        this.contentNode.appendChild(tab.node);
        // Select the tab if no tab is currently selected.
        if (!this.currentItem)
            this.currentItem = tab.item;
        // Update the tab node order.
        this.update();
    };
    /**
     * The handler invoked on a items list change of type `Move`.
     */
    TabBar.prototype._onItemsListMove = function (args) {
        // Ensure the mouse is released.
        this._releaseMouse();
        // Move the tab in the array. DOM position is irrelevant.
        arrays.move(this._tabs, args.oldIndex, args.newIndex);
        // Update the tab node order.
        this.update();
    };
    /**
     * The handler invoked on a items list change of type `Remove`.
     */
    TabBar.prototype._onItemsListRemove = function (args) {
        // Ensure the mouse is released.
        this._releaseMouse();
        // Remove the tab from the internal array.
        var tab = arrays.removeAt(this._tabs, args.oldIndex);
        // Remove the tab node from the DOM.
        this.contentNode.removeChild(tab.node);
        // Patch up the current item if needed.
        if (this.currentItem === tab.item) {
            var list = this.items;
            this.currentItem = list.get(args.oldIndex) || list.get(-1);
        }
        // Dispose of the old tab.
        tab.dispose();
        // Update the tab node order.
        this.update();
    };
    /**
     * The handler invoked on a items list change of type `Replace`.
     */
    TabBar.prototype._onItemsListReplace = function (args) {
        // Ensure the mouse is released.
        this._releaseMouse();
        // Create the new tabs for the new tab items.
        var newItems = args.newValue;
        var newTabs = newItems.map(function (item) { return new Tab(item); });
        // Replace the tabs in the internal array.
        var oldItems = args.oldValue;
        var oldTabs = (_a = this._tabs).splice.apply(_a, [args.newIndex, oldItems.length].concat(newTabs));
        // Remove the old tabs from the DOM.
        var content = this.contentNode;
        oldTabs.forEach(function (tab) { content.removeChild(tab.node); });
        // Add the new tabs to the DOM. Their position is irrelevant.
        newTabs.forEach(function (tab) { content.appendChild(tab.node); });
        // Patch up the current item if needed.
        var curr = this.currentItem;
        if (oldItems.indexOf(curr) !== -1) {
            this.currentItem = null;
            if (newItems.indexOf(curr) !== -1) {
                this.currentItem = curr;
            }
            else {
                var list = this.items;
                this.currentItem = list.get(args.newIndex) || list.get(-1);
            }
        }
        // Dispose of the old tabs.
        oldTabs.forEach(function (tab) { tab.dispose(); });
        // Update the tab node order.
        this.update();
        var _a;
    };
    /**
     * The handler invoked on a items list change of type `Set`.
     */
    TabBar.prototype._onItemsListSet = function (args) {
        // If the item was not actually changed, there is nothing to do.
        if (args.oldValue === args.newValue) {
            return;
        }
        // Ensure the mouse is released.
        this._releaseMouse();
        // Create the tab for the new tab item.
        var newTab = new Tab(args.newValue);
        // Swap the new tab in the internal array.
        var oldTab = this._tabs[args.newIndex];
        this._tabs[args.newIndex] = newTab;
        // Swap the new tab node in the DOM.
        this.contentNode.replaceChild(newTab.node, oldTab.node);
        // Patch up the current item if needed.
        if (this.currentItem === oldTab.item) {
            this.currentItem = newTab.item;
        }
        // Dispose of the old tab.
        oldTab.dispose();
        // Update the tab node order.
        this.update();
    };
    /**
     * A signal emitted when the user clicks a tab item's close icon.
     *
     * **See also:** [[itemCloseRequested]]
     */
    TabBar.itemCloseRequestedSignal = new phosphor_signaling_1.Signal();
    /**
     * The property descriptor for the currently selected tab item.
     *
     * **See also:** [[currentItem]]
     */
    TabBar.currentItemProperty = new phosphor_properties_1.Property({
        name: 'currentItem',
        value: null,
        coerce: function (owner, value) { return owner._coerceCurrentItem(value); },
        changed: function (owner, old, value) { owner._onCurrentItemChanged(old, value); },
        notify: new phosphor_signaling_1.Signal(),
    });
    /**
     * The property descriptor for the observable list of tab items.
     *
     * **See also:** [[items]]
     */
    TabBar.itemsProperty = new phosphor_properties_1.Property({
        name: 'items',
        value: null,
        coerce: function (owner, value) { return value || null; },
        changed: function (owner, old, value) { owner._onItemsChanged(old, value); },
    });
    /**
     * The property descriptor for whether the tabs are user-movable.
     *
     * **See also:** [[tabsMovable]]
     */
    TabBar.tabsMovableProperty = new phosphor_properties_1.Property({
        name: 'tabsMovable',
        value: false,
        changed: function (owner) { owner._releaseMouse(); },
    });
    return TabBar;
})(phosphor_widget_1.Widget);
exports.TabBar = TabBar;
/**
 * A message class for `'tear-off-request'` messages.
 *
 * #### Notes
 * A message of this type is sent to a tab bar when the user drags
 * a tab beyond the tear-off threshold which surrounds the tab bar.
 */
var TearOffMessage = (function (_super) {
    __extends(TearOffMessage, _super);
    /**
     * Construct a new tear off request message.
     *
     * @param item - The tab item being dragged by the user.
     *
     * @param node - The DOM node for the item tab.
     *
     * @param clientX - The current client X position of the mouse.
     *
     * @param clientY - The current client Y position of the mouse.
     */
    function TearOffMessage(item, node, clientX, clientY) {
        _super.call(this, 'tear-off-request');
        this._item = item;
        this._node = node;
        this._clientX = clientX;
        this._clientY = clientY;
    }
    Object.defineProperty(TearOffMessage.prototype, "item", {
        /**
         * The tab item being dragged by the user.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._item;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TearOffMessage.prototype, "node", {
        /**
         * The DOM node which represents the tab.
         *
         * #### Notes
         * This node *must not* be removed from the DOM, but it can be cloned
         * for use as a ghost node which follows the cursor during dragging.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._node;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TearOffMessage.prototype, "clientX", {
        /**
         * The current client X position of the mouse.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._clientX;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TearOffMessage.prototype, "clientY", {
        /**
         * The current client Y position of the mouse.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._clientY;
        },
        enumerable: true,
        configurable: true
    });
    return TearOffMessage;
})(phosphor_messaging_1.Message);
exports.TearOffMessage = TearOffMessage;
/**
 * An object which manages a tab node for a tab bar.
 */
var Tab = (function (_super) {
    __extends(Tab, _super);
    /**
     * Construct a new tab.
     *
     * @param item - The tab item to associate with the tab.
     */
    function Tab(item) {
        _super.call(this);
        this.addClass(TAB_CLASS);
        this._item = item;
        var title = item.title;
        this.textNode.textContent = title.text;
        this.toggleClass(CLOSABLE_CLASS, title.closable);
        if (title.icon)
            exAddClass(this.iconNode, title.icon);
        if (title.className)
            exAddClass(this.node, title.className);
        title.changed.connect(this._onTitleChanged, this);
    }
    /**
     * Create the DOM node for a tab.
     */
    Tab.createNode = function () {
        var node = document.createElement('li');
        var icon = document.createElement('span');
        var text = document.createElement('span');
        var close = document.createElement('span');
        icon.className = ICON_CLASS;
        text.className = TEXT_CLASS;
        close.className = CLOSE_CLASS;
        node.appendChild(icon);
        node.appendChild(text);
        node.appendChild(close);
        return node;
    };
    /**
     * Dispose of the resources held by the tab.
     */
    Tab.prototype.dispose = function () {
        this._item = null;
        phosphor_signaling_1.clearSignalData(this);
    };
    Object.defineProperty(Tab.prototype, "isDisposed", {
        /**
         * Test whether the tab is disposed.
         */
        get: function () {
            return this._item === null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tab.prototype, "iconNode", {
        /**
         * Get the icon node for the tab.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this.node.childNodes[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tab.prototype, "textNode", {
        /**
         * Get the text node for the tab.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this.node.childNodes[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tab.prototype, "closeNode", {
        /**
         * Get the close icon node for the tab.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this.node.childNodes[2];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tab.prototype, "item", {
        /**
         * Get the tab item associated with the tab.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._item;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * The handler for the title `changed` signal.
     */
    Tab.prototype._onTitleChanged = function (sender, args) {
        switch (args.name) {
            case 'text':
                this._onTitleTextChanged(args);
                break;
            case 'icon':
                this._onTitleIconChanged(args);
                break;
            case 'closable':
                this._onTitleClosableChanged(args);
                break;
            case 'className':
                this._onTitleClassNameChanged(args);
                break;
        }
    };
    /**
     * A method invoked when the title text changes.
     */
    Tab.prototype._onTitleTextChanged = function (args) {
        this.textNode.textContent = args.newValue;
    };
    /**
     * A method invoked when the title icon changes.
     */
    Tab.prototype._onTitleIconChanged = function (args) {
        var node = this.iconNode;
        if (args.oldValue)
            exRemClass(node, args.oldValue);
        if (args.newValue)
            exAddClass(node, args.newValue);
    };
    /**
     * A method invoked when the title closable flag changes.
     */
    Tab.prototype._onTitleClosableChanged = function (args) {
        this.toggleClass(CLOSABLE_CLASS, args.newValue);
    };
    /**
     * A method invoked when the title class name changes.
     */
    Tab.prototype._onTitleClassNameChanged = function (args) {
        var node = this.node;
        if (args.oldValue)
            exRemClass(node, args.oldValue);
        if (args.newValue)
            exAddClass(node, args.newValue);
    };
    return Tab;
})(phosphor_nodewrapper_1.NodeWrapper);
/**
 * A struct which holds the drag data for a tab bar.
 */
var DragData = (function () {
    function DragData() {
        /**
         * The tab object being dragged.
         */
        this.tab = null;
        /**
         * The index of the tab being dragged.
         */
        this.tabIndex = -1;
        /**
         * The offset left of the tab being dragged.
         */
        this.tabLeft = -1;
        /**
         * The offset width of the tab being dragged.
         */
        this.tabWidth = -1;
        /**
         * The original mouse X position in tab coordinates.
         */
        this.tabPressX = -1;
        /**
         * The tab target index upon mouse release.
         */
        this.tabTargetIndex = -1;
        /**
         * The array of tab layout objects snapped at drag start.
         */
        this.tabLayout = null;
        /**
         * The mouse press client X position.
         */
        this.pressX = -1;
        /**
         * The mouse press client Y position.
         */
        this.pressY = -1;
        /**
         * The bounding client rect of the tab bar content node.
         */
        this.contentRect = null;
        /**
         * The disposable to clean up the cursor override.
         */
        this.cursorGrab = null;
        /**
         * Whether the drag is currently active.
         */
        this.dragActive = false;
        /**
         * Whether a tear-off request as been made.
         */
        this.tearOffRequested = false;
    }
    return DragData;
})();
/**
 * Add a whitespace separated class name to the given node.
 */
function exAddClass(node, name) {
    var list = node.classList;
    var parts = name.split(/\s+/);
    for (var i = 0, n = parts.length; i < n; ++i) {
        if (parts[i])
            list.add(parts[i]);
    }
}
/**
 * Remove a whitespace separated class name to the given node.
 */
function exRemClass(node, name) {
    var list = node.classList;
    var parts = name.split(/\s+/);
    for (var i = 0, n = parts.length; i < n; ++i) {
        if (parts[i])
            list.remove(parts[i]);
    }
}
/**
 * Perform a client position hit test an array of tabs.
 *
 * Returns the index of the first matching node, or `-1`.
 */
function hitTestTabs(tabs, clientX, clientY) {
    for (var i = 0, n = tabs.length; i < n; ++i) {
        if (phosphor_domutil_1.hitTest(tabs[i].node, clientX, clientY))
            return i;
    }
    return -1;
}
/**
 * Get a snapshot of the current tab layout values.
 */
function snapTabLayout(tabs) {
    var layout = new Array(tabs.length);
    for (var i = 0, n = tabs.length; i < n; ++i) {
        var node = tabs[i].node;
        var left = node.offsetLeft;
        var width = node.offsetWidth;
        var cstyle = window.getComputedStyle(node);
        var margin = parseInt(cstyle.marginLeft, 10) || 0;
        layout[i] = { margin: margin, left: left, width: width };
    }
    return layout;
}
/**
 * Test if a mouse position exceeds the tear-off threshold.
 */
function tearOffExceeded(rect, event) {
    return ((event.clientX < rect.left - TEAR_OFF_THRESHOLD) ||
        (event.clientX >= rect.right + TEAR_OFF_THRESHOLD) ||
        (event.clientY < rect.top - TEAR_OFF_THRESHOLD) ||
        (event.clientY >= rect.bottom + TEAR_OFF_THRESHOLD));
}
//# sourceMappingURL=tabbar.js.map