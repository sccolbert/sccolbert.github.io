{
  "name": "phosphor-signaling",
  "version": "1.2.0",
  "description": "A module for type-safe inter-object communication.",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "dependencies": {},
  "devDependencies": {
    "coveralls": "^2.11.4",
    "expect.js": "^0.3.1",
    "istanbul": "^0.3.19",
    "mocha": "^2.2.5",
    "rimraf": "^2.4.2",
    "typedoc": "^0.3.11",
    "typescript": "^1.6.2"
  },
  "scripts": {
    "clean": "rimraf lib && rimraf test/build && rimraf test/coverage",
    "build:src": "tsc --project src",
    "build:test": "tsc --project test/src",
    "build": "npm run build:src && npm run build:test",
    "docs": "rimraf docs/api && typedoc --options scripts/tdoptions.json",
    "prepublish": "npm run build",
    "test": "mocha test/build/index.js",
    "test:coverage": "istanbul cover --dir test/coverage node_modules/mocha/bin/_mocha -- test/build/index.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/phosphorjs/phosphor-signaling.git"
  },
  "files": [
    "lib/*.d.ts",
    "lib/*.js"
  ],
  "keywords": [
    "signal",
    "signals",
    "slot",
    "slots"
  ],
  "author": {
    "name": "S. Chris Colbert",
    "email": "sccolbert@gmail.com"
  },
  "license": "BSD-3-Clause",
  "bugs": {
    "url": "https://github.com/phosphorjs/phosphor-signaling/issues"
  },
  "homepage": "https://github.com/phosphorjs/phosphor-signaling",
  "readme": "phosphor-signaling\r\n==================\r\n\r\n[![Build Status](https://travis-ci.org/phosphorjs/phosphor-signaling.svg)](https://travis-ci.org/phosphorjs/phosphor-signaling?branch=master)\r\n[![Coverage Status](https://coveralls.io/repos/phosphorjs/phosphor-signaling/badge.svg?branch=master&service=github)](https://coveralls.io/github/phosphorjs/phosphor-signaling?branch=master)\r\n\r\nA module for type-safe inter-object communication.\r\n\r\n[API Docs](http://phosphorjs.github.io/phosphor-signaling/api/)\r\n\r\n\r\nPackage Install\r\n---------------\r\n\r\n**Prerequisites**\r\n- [node](http://nodejs.org/)\r\n\r\n```bash\r\nnpm install --save phosphor-signaling\r\n```\r\n\r\n\r\nSource Build\r\n------------\r\n\r\n**Prerequisites**\r\n- [git](http://git-scm.com/)\r\n- [node](http://nodejs.org/)\r\n\r\n```bash\r\ngit clone https://github.com/phosphorjs/phosphor-signaling.git\r\ncd phosphor-signaling\r\nnpm install\r\n```\r\n\r\n**Rebuild**\r\n```bash\r\nnpm run clean\r\nnpm run build\r\n```\r\n\r\n\r\nRun Tests\r\n---------\r\n\r\nFollow the source build instructions first.\r\n\r\n```bash\r\nnpm test\r\n```\r\n\r\n\r\nBuild Docs\r\n----------\r\n\r\nFollow the source build instructions first.\r\n\r\n```bash\r\nnpm run docs\r\n```\r\n\r\nNavigate to `docs/index.html`.\r\n\r\n\r\nSupported Runtimes\r\n------------------\r\n\r\nThe runtime versions which are currently *known to work* are listed below.\r\nEarlier versions may also work, but come with no guarantees.\r\n\r\n- Node 0.12.7+\r\n- IE 11+\r\n- Firefox 32+\r\n- Chrome 38+\r\n\r\n\r\nBundle for the Browser\r\n----------------------\r\n\r\nFollow the package install instructions first.\r\n\r\n```bash\r\nnpm install --save-dev browserify\r\nbrowserify myapp.js -o mybundle.js\r\n```\r\n\r\n\r\nUsage Examples\r\n--------------\r\n\r\n**Note:** This module is fully compatible with Node/Babel/ES6/ES5. Simply\r\nomit the type declarations when using a language other than TypeScript.\r\n\r\n**Recommended Design Patterns:**\r\n\r\nClass authors should strive to maintain consistency in how their classes\r\nexpose signals to consumers. The PhosphorJS project has adopted a set of\r\nconventions which cover signal naming and exposure. It is recommended for\r\nthird party libraries to adopt these same conventions in order to ensure\r\nAPI consistency and maximal compatibility with libraries and meta tools\r\nwhich rely on these conventions.\r\n\r\nWhen defining a signal for use by instances of the **same** class:\r\n\r\n  - Define the signal as a static member of the class.\r\n\r\n  - Ensure the class type is used as the signal owner type.\r\n\r\n  - Append the suffix `'Signal'` to the static member name.\r\n\r\n  - Define a public getter which binds the static signal to\r\n    the instance. This getter should contain no logic outside\r\n    of binding the signal.\r\n\r\n  - The name of the getter should be the same as the name of\r\n    the static signal minus the `'Signal'` suffix.\r\n\r\n  - Consumers should normally use the getter to access the signal,\r\n    but meta tools and code generators are free to use the static\r\n    API directly. This is why the getter must be a pure delegate\r\n    as described above.\r\n\r\n```typescript\r\nimport { ISignal, Signal } from 'phosphor-signaling';\r\n\r\n\r\nclass MyClass {\r\n\r\n  static valueChangedSignal = new Signal<MyClass, number>();\r\n\r\n  constructor(name: string) {\r\n    this._name = name;\r\n  }\r\n\r\n  get valueChanged(): ISignal<MyClass, number> {\r\n    return MyClass.valueChangedSignal.bind(this);\r\n  }\r\n\r\n  get name(): string {\r\n    return this._name;\r\n  }\r\n\r\n  get value(): number {\r\n    return this._value;\r\n  }\r\n\r\n  set value(value: number) {\r\n    if (value !== this._value) {\r\n      this._value = value;\r\n      this.valueChanged.emit(value);\r\n    }\r\n  }\r\n\r\n  private _name: string;\r\n  private _value = 0;\r\n}\r\n\r\n\r\nclass MyHandler {\r\n\r\n  constructor(model: MyClass, name: string) {\r\n    this._model = model;\r\n    this._name = name;\r\n    model.valueChanged.connect(this._onValueChanged, this);\r\n  }\r\n\r\n  dispose(): void {\r\n    this._model.valueChanged.disconnect(this._onValueChanged, this);\r\n    this._model = null;\r\n  }\r\n\r\n  private _onValueChanged(sender: MyClass, value: number): void {\r\n    console.log(this._name, value);\r\n  }\r\n\r\n  private _name: string;\r\n  private _model: MyClass;\r\n}\r\n\r\n\r\nfunction logger(sender: MyClass, value: number): void {\r\n  console.log(sender.name, value);\r\n}\r\n\r\n\r\nvar m1 = new MyClass('foo');\r\nvar m2 = new MyClass('bar');\r\n\r\nm1.valueChanged.connect(logger);\r\nm2.valueChanged.connect(logger);\r\n\r\nvar h1 = new MyHandler(m1, 'ham');\r\nvar h2 = new MyHandler(m2, 'eggs');\r\n\r\nm1.value = 42;  // logs: foo 42, ham 42\r\nm2.value = 17;  // logs: bar 17, eggs 17\r\n```\r\n\r\nWhen defining a signal for use by instances of a **different** class:\r\n\r\n  - Define the signal as a static member of the class.\r\n\r\n  - Ensure the instance type is used as the signal owner type.\r\n\r\n  - Append the suffix `'Signal'` to the static member name.\r\n\r\n  - Define a static method to get the bound signal for a particular\r\n    instance of the owner type. This method should contain no logic\r\n    outside of binding the signal.\r\n\r\n  - Name the static method by prepending `'get'` to the capitalized\r\n    signal name. Omit the `'Signal'` suffix.\r\n\r\n  - Consumers should normally use the static method to access the\r\n    bound signal, but meta tools and code generators are free to\r\n    use the static API directly. This is why the method must be\r\n    a pure delegate as described above.\r\n\r\nThis pattern is referred to as an *attached signal*. The signal is defined\r\nby one class, but the sender is a foreign instance. This pattern is useful\r\nwhen creating container objects which must emit signals for child objects\r\nin a way which doesn't require polluting the child class with extraneous\r\nsignal definitions.\r\n\r\n```typescript\r\nclass MyItem {\r\n  // ...\r\n}\r\n\r\n\r\nclass MyContainer {\r\n\r\n  static valueChangedSignal = new Signal<MyItem, number>();\r\n\r\n  static getValueChanged(item: MyItem): ISignal<MyItem, number> {\r\n    return MyContainer.valueChangedSignal.bind(item);\r\n  }\r\n\r\n  getValue(item: MyItem): number {\r\n    // ...\r\n  }\r\n\r\n  setValue(item: MyItem, value: number): void {\r\n    // ...\r\n    MyContainer.getValueChanged(item).emit(value);\r\n  }\r\n}\r\n```\r\n\r\n**Auxiliary API:**\r\n\r\n```typescript\r\nimport {\r\n  clearSignalData, disconnectReceiver, disconnectSender\r\n} from 'phosphor-signaling';\r\n\r\n\r\n// Disconnect a handler from all models in a single-shot.\r\ndisconnectReceiver(handler);\r\n\r\n// Disconnect a particular model from all handlers in a single-shot.\r\ndisconnectSender(model);\r\n\r\n// disconnect everything - sender *and* receiver\r\nclearSignalData(model);\r\n```\r\n",
  "readmeFilename": "README.md",
  "gitHead": "1ae9602f8344d4d873da6d22628388525f2f4223",
  "_id": "phosphor-signaling@1.2.0",
  "_shasum": "f757d6af1ab1683d16bf686ad0bfd50195ed5daa",
  "_from": "phosphor-signaling@1.2.0"
}
