/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var arrays = require('phosphor-arrays');
var phosphor_messaging_1 = require('phosphor-messaging');
var phosphor_observablelist_1 = require('phosphor-observablelist');
var phosphor_signaling_1 = require('phosphor-signaling');
var messages_1 = require('./messages');
var widget_1 = require('./widget');
/**
 * The class name added to Panel instances.
 */
var PANEL_CLASS = 'p-Panel';
/**
 * A widget which acts as a layout container for child widgets.
 *
 * #### Notes
 * This class typically serves as a base class for more concrete layout
 * panels, but can be used directly in combination with CSS to achieve
 * any desired layout for a collection of widgets.
 */
var Panel = (function (_super) {
    __extends(Panel, _super);
    /**
     * Construct a new panel.
     */
    function Panel() {
        _super.call(this);
        this.addClass(PANEL_CLASS);
        this._children = new ChildWidgetList(this);
    }
    Object.defineProperty(Panel.prototype, "children", {
        /**
         * Get the observable list of child widgets for the panel.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._children;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Process a message sent to the panel.
     *
     * @param msg - The message sent to the panel.
     *
     * #### Notes
     * Subclasses may reimplement this method as needed.
     */
    Panel.prototype.processMessage = function (msg) {
        switch (msg.type) {
            case 'layout-request':
                this.onLayoutRequest(msg);
                break;
            case 'child-added':
                this.onChildAdded(msg);
                break;
            case 'child-moved':
                this.onChildMoved(msg);
                break;
            case 'child-removed':
                this.onChildRemoved(msg);
                break;
            case 'child-shown':
                this.onChildShown(msg);
                break;
            case 'child-hidden':
                this.onChildHidden(msg);
                break;
            default:
                _super.prototype.processMessage.call(this, msg);
        }
    };
    /**
     * Compress a message posted to the panel.
     *
     * @param msg - The message posted to the panel.
     *
     * @param pending - The queue of pending messages for the panel.
     *
     * @returns `true` if the message was compressed and should be
     *   dropped, or `false` if the message should be enqueued for
     *   delivery as normal.
     *
     * #### Notes
     * This compresses `'layout-request'` messages in addition to the
     * compression provided by the base `Widget` class.
     *
     * Subclasses may reimplement this method as needed.
     */
    Panel.prototype.compressMessage = function (msg, pending) {
        if (msg.type === 'layout-request') {
            return pending.some(function (other) { return other.type === 'layout-request'; });
        }
        return _super.prototype.compressMessage.call(this, msg, pending);
    };
    /**
     * A message handler invoked on a `'child-added'` message.
     *
     * #### Notes
     * The default implementation adds the child node to the panel node
     * at the proper location and sends an `'after-attach'` message to
     * the child if the panel is attached to the DOM.
     *
     * Subclasses may reimplement this method to control how the child
     * node is added to the panel node, but a reimplementation must send
     * an `'after-attach'` message to the child if the panel is attached
     * to the DOM.
     */
    Panel.prototype.onChildAdded = function (msg) {
        var next = this.children.get(msg.currentIndex + 1);
        this.node.insertBefore(msg.child.node, next && next.node);
        if (this.isAttached)
            phosphor_messaging_1.sendMessage(msg.child, widget_1.Widget.MsgAfterAttach);
    };
    /**
     * A message handler invoked on a `'child-moved'` message.
     *
     * #### Notes
     * The default implementation moves the child node to the proper
     * location in the panel node and sends both `'before-detach'` and
     * `'after-attach'` message to the child if the panel is attached
     * to the DOM.
     *
     * Subclasses may reimplement this method to control how the child
     * node is moved in the panel node, but a reimplementation must send
     * both `'before-detach'` and `'after-attach'` message to the child
     * if the panel is attached to the DOM.
     */
    Panel.prototype.onChildMoved = function (msg) {
        if (this.isAttached)
            phosphor_messaging_1.sendMessage(msg.child, widget_1.Widget.MsgBeforeDetach);
        var next = this.children.get(msg.currentIndex + 1);
        this.node.insertBefore(msg.child.node, next && next.node);
        if (this.isAttached)
            phosphor_messaging_1.sendMessage(msg.child, widget_1.Widget.MsgAfterAttach);
    };
    /**
     * A message handler invoked on a `'child-removed'` message.
     *
     * #### Notes
     * The default implementation removes the child node from the panel
     * node and sends a `'before-detach'` message to the child if the
     * panel is attached to the DOM.
     *
     * Subclasses may reimplement this method to control how the child
     * node is removed from the panel node, but a reimplementation must
     * send a `'before-detach'` message to the child if the panel is
     * attached to the DOM.
     */
    Panel.prototype.onChildRemoved = function (msg) {
        if (this.isAttached)
            phosphor_messaging_1.sendMessage(msg.child, widget_1.Widget.MsgBeforeDetach);
        this.node.removeChild(msg.child.node);
    };
    /**
     * A message handler invoked on a `'resize'` message.
     *
     * #### Notes
     * The default implementation of this handler sends an [[UnknownSize]]
     * resize message to each child. This ensures that the resize messages
     * propagate through all widgets in the hierarchy.
     *
     * Subclasses may reimplement this method as needed, but they must
     * dispatch `'resize'` messages to their children as appropriate.
     */
    Panel.prototype.onResize = function (msg) {
        var children = this.children;
        for (var i = 0; i < children.length; ++i) {
            phosphor_messaging_1.sendMessage(children.get(i), messages_1.ResizeMessage.UnknownSize);
        }
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     *
     * #### Notes
     * The default implementation of this handler sends an [[UnknownSize]]
     * resize message to each child. This ensures that the all widgets in
     * the hierarchy remain correctly sized on updates.
     *
     * Subclasses may reimplement this method as needed, but they should
     * dispatch `'resize'` messages to their children if appropriate.
     */
    Panel.prototype.onUpdateRequest = function (msg) {
        var children = this.children;
        for (var i = 0; i < children.length; ++i) {
            phosphor_messaging_1.sendMessage(children.get(i), messages_1.ResizeMessage.UnknownSize);
        }
    };
    /**
     * A message handler invoked on an `'after-show'` message.
     *
     * #### Notes
     * The default implementation of this handler forwards the message
     * to all of its non-hidden children.
     *
     * Subclasses may reimplement this method as needed, but they should
     * either call the superclass implementation or forward the message
     * to their non-hidden children as appropriate.
     */
    Panel.prototype.onAfterShow = function (msg) {
        var children = this.children;
        for (var i = 0; i < children.length; ++i) {
            var child = children.get(i);
            if (!child.hidden)
                phosphor_messaging_1.sendMessage(child, msg);
        }
    };
    /**
     * A message handler invoked on a `'before-hide'` message.
     *
     * #### Notes
     * The default implementation of this handler forwards the message
     * to all of its non-hidden children.
     *
     * Subclasses may reimplement this method as needed, but they should
     * either call the superclass implementation or forward the message
     * to their children as appropriate.
     */
    Panel.prototype.onBeforeHide = function (msg) {
        var children = this.children;
        for (var i = 0; i < children.length; ++i) {
            var child = children.get(i);
            if (!child.hidden)
                phosphor_messaging_1.sendMessage(child, msg);
        }
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     *
     * #### Notes
     * The default implementation of this handler forwards the message
     * to all of its children.
     *
     * Subclasses may reimplement this method as needed, but they should
     * either call the superclass implementation or forward the message
     * to their children as appropriate.
     */
    Panel.prototype.onAfterAttach = function (msg) {
        var children = this.children;
        for (var i = 0; i < children.length; ++i) {
            phosphor_messaging_1.sendMessage(children.get(i), msg);
        }
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     *
     * #### Notes
     * The default implementation of this handler forwards the message
     * to all of its children.
     *
     * Subclasses may reimplement this method as needed, but they should
     * either call the superclass implementation or forward the message
     * to their children as appropriate.
     */
    Panel.prototype.onBeforeDetach = function (msg) {
        var children = this.children;
        for (var i = 0; i < children.length; ++i) {
            phosphor_messaging_1.sendMessage(children.get(i), msg);
        }
    };
    /**
     * A message handler invoked on a `'layout-request'` message.
     *
     * The default implementation of this handler is a no-op.
     */
    Panel.prototype.onLayoutRequest = function (msg) { };
    /**
     * A message handler invoked on a `'child-shown'` message.
     *
     * The default implementation of this handler is a no-op.
     */
    Panel.prototype.onChildShown = function (msg) { };
    /**
     * A message handler invoked on a `'child-hidden'` message.
     *
     * The default implementation of this handler is a no-op.
     */
    Panel.prototype.onChildHidden = function (msg) { };
    /**
     * A singleton `'layout-request'` message.
     *
     * #### Notes
     * This message can be dispatched to supporting panels in order to
     * update their layout. Not all panels will respond to messages of
     * this type.
     *
     * This message is typically used to update the size constraints of
     * a panel and to update the position and size of its children.
     *
     * Messages of this type are compressed by default.
     *
     * **See also:** [[onLayoutRequest]]
     */
    Panel.MsgLayoutRequest = new phosphor_messaging_1.Message('layout-request');
    return Panel;
})(widget_1.Widget);
exports.Panel = Panel;
/**
 * A concrete implementation of IChildWidgetList.
 */
var ChildWidgetList = (function (_super) {
    __extends(ChildWidgetList, _super);
    /**
     * Construct a new child widget list.
     *
     * @param parent - The panel to use as the parent of the children.
     */
    function ChildWidgetList(parent) {
        _super.call(this);
        this._parent = parent;
    }
    /**
     * Dispose of the child widgets in the list.
     *
     * #### Notes
     * This will unparent, remove, and dispose of all child widgets.
     *
     * This will not emit change notifications or send messages to
     * the parent panel.
     */
    ChildWidgetList.prototype.dispose = function () {
        // Clear the signal data so prevent any further notifications.
        phosphor_signaling_1.clearSignalData(this);
        // Set the parent to `null` to indicate the list is destroyed.
        this._parent = null;
        // Remove all children, set their internal parent references to
        // `null`, and dispose them. The `any` cast is required to work
        // around the lack of `friend class` modifiers.
        while (this.internal.length > 0) {
            var child = this.internal.pop();
            child._parent = null;
            child.dispose();
        }
    };
    Object.defineProperty(ChildWidgetList.prototype, "isDisposed", {
        /**
         * Test whether the widget list is disposed.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._parent === null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChildWidgetList.prototype, "parent", {
        /**
         * The parent panel which owns the list.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._parent;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add an item to the list at the specified index.
     *
     * @param index - The index at which to add the item. This must be
     *   an integer in the range `[0, internal.length]`.
     *
     * @param item - The item to add at the specified index.
     *
     * @returns The index at which the item was added.
     *
     * #### Notes
     * If the item is the parent panel, an error will be thrown.
     *
     * If the item is already a child widget, it will be moved.
     *
     * If the item has a foreign parent, it will first be removed.
     *
     * This will dispatch an appropriate child message to the parent.
     */
    ChildWidgetList.prototype.addItem = function (index, item) {
        // Throw an error if the item is the parent panel.
        if (item === this._parent) {
            throw new Error('invalid child widget');
        }
        // Move the item if it is already a child.
        if (item.parent === this._parent) {
            var i_1 = this.internal.indexOf(item);
            var j = i_1 < index ? index - 1 : index;
            this.moveItem(i_1, j);
            return j;
        }
        // Remove or detach the item if necessary.
        if (item.parent) {
            item.parent.children.remove(item);
        }
        else if (item.isAttached) {
            widget_1.Widget.detach(item);
        }
        // Update the internal parent reference of the item. The `any` cast
        // is required to work around the lack of `friend class` modifiers.
        item._parent = this._parent;
        // Insert the item into the internal array.
        var i = arrays.insert(this.internal, index, item);
        // Dispatch a `'child-added'` message to the parent.
        var msg = new messages_1.ChildMessage('child-added', item, -1, i);
        phosphor_messaging_1.sendMessage(this._parent, msg);
        // Emit the list changed signal.
        this.changed.emit({
            type: phosphor_observablelist_1.ListChangeType.Add,
            newIndex: i,
            newValue: item,
            oldIndex: -1,
            oldValue: void 0,
        });
        // Return the new index of the item.
        return i;
    };
    /**
     * Move an item in the list from one index to another.
     *
     * @param fromIndex - The initial index of the item. This must be
     *   an integer in the range `[0, internal.length)`.
     *
     * @param toIndex - The desired index for the item. This must be
     *   an integer in the range `[0, internal.length)`.
     *
     * @returns `true` if the item was moved, `false` otherwise.
     *
     * #### Notes
     * If the `from` and `to` indices are the same, this is a no-op.
     *
     * This will dispatch an appropriate child message to the parent.
     */
    ChildWidgetList.prototype.moveItem = function (fromIndex, toIndex) {
        // Do nothing if the `from` and `to` indices are the same.
        if (fromIndex === toIndex) {
            return true;
        }
        // Move the item in the internal array.
        if (!arrays.move(this.internal, fromIndex, toIndex)) {
            return false;
        }
        // Dispatch a `'child-moved'` message to the parent.
        var item = this.internal[toIndex];
        var msg = new messages_1.ChildMessage('child-moved', item, fromIndex, toIndex);
        phosphor_messaging_1.sendMessage(this._parent, msg);
        // Emit the list changed signal.
        this.changed.emit({
            type: phosphor_observablelist_1.ListChangeType.Move,
            newIndex: toIndex,
            newValue: item,
            oldIndex: fromIndex,
            oldValue: item,
        });
        // Return `true` for success.
        return true;
    };
    /**
     * Remove the item from the list at the specified index.
     *
     * @param index - The index of the item to remove. This must be
     *   an integer in the range `[0, internal.length)`.
     *
     * @returns The item removed from the list.
     *
     * #### Notes
     * This will dispatch an appropriate child message to the parent.
     */
    ChildWidgetList.prototype.removeItem = function (index) {
        // Remove the item from the internal array.
        var item = arrays.removeAt(this.internal, index);
        // Update the internal parent reference of the item. The `any` cast
        // is required to work around the lack of `friend class` modifiers.
        item._parent = null;
        // Dispatch a `'child-removed'` message to the parent.
        var msg = new messages_1.ChildMessage('child-removed', item, index, -1);
        phosphor_messaging_1.sendMessage(this._parent, msg);
        // Emit the list changed signal.
        this.changed.emit({
            type: phosphor_observablelist_1.ListChangeType.Remove,
            newIndex: -1,
            newValue: void 0,
            oldIndex: index,
            oldValue: item,
        });
        // Return the removed item.
        return item;
    };
    /**
     * Replace items at a specific location in the list.
     *
     * @param index - The index at which to modify the list. This must
     *   be an integer in the range `[0, internal.length]`.
     *
     * @param count - The number of items to remove from the list. This
     *   must be an integer in the range `[0, internal.length]`.
     *
     * @param items - The items to insert at the specified index.
     *
     * @returns An array of the items removed from the list.
     *
     * #### Notes
     * If any new item is the parent panel, an error will be thrown.
     *
     * This decomposes the operation into a sequence of remove + add.
     *
     * This will dispatch appropriate child messages to the parent.
     */
    ChildWidgetList.prototype.replaceItems = function (index, count, items) {
        var _this = this;
        // Throw an error if any item is the parent panel.
        if (items.some(function (item) { return item === _this._parent; })) {
            throw new Error('invalid child widget');
        }
        // Remove the old items from the list.
        var old = [];
        while (count-- > 0 && index < this.internal.length) {
            old.push(this.removeItem(index));
        }
        // Add the new items to the list and remove them from the old.
        for (var i = 0, n = items.length; i < n; ++i) {
            index = this.addItem(index, items[i]) + 1;
            arrays.remove(old, items[i]);
        }
        // Return the items which were removed.
        return old;
    };
    /**
     * Set the item at a specific index in the list.
     *
     * @param index - The index of interest. This must be an integer in
     *   the range `[0, internal.length)`.
     *
     * @param item - The item to set at the index.
     *
     * @returns The item which previously occupied the specified index.
     *
     * #### Notes
     * If the item is the parent panel, an error will be thrown.
     *
     * If old item is the same as the new item, this is a no-op.
     *
     * This decomposes the operation into an equivalent remove + add.
     *
     * This will dispatch appropriate child messages to the parent.
     */
    ChildWidgetList.prototype.setItem = function (index, item) {
        // Throw an error if the item is the parent panel.
        if (item === this._parent) {
            throw new Error('invalid child widget');
        }
        // Do nothing if the old item is the same as the new item.
        if (this.internal[index] === item) {
            return item;
        }
        // Remove the old item from the list.
        var old = this.removeItem(index);
        // Add the new item to the list.
        this.addItem(index, item);
        // Return the old item.
        return old;
    };
    return ChildWidgetList;
})(phosphor_observablelist_1.ObservableList);
//# sourceMappingURL=panel.js.map