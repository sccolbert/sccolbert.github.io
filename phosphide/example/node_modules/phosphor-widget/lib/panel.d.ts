import { IDisposable } from 'phosphor-disposable';
import { Message } from 'phosphor-messaging';
import { IObservableList } from 'phosphor-observablelist';
import { Queue } from 'phosphor-queue';
import { ChildMessage, ResizeMessage } from './messages';
import { Widget } from './widget';
/**
 * An observable list which manages the child widgets for a panel.
 *
 * #### Notes
 * A child widget list must ensure that the child widgets are unique,
 * and must therefore decompose list modifications into `Add`, `Move`,
 * and `Remove` primitive operations. The list will **never** emit its
 * changed signal with a change type of `Replace` or `Set`.
 *
 * A child widget list is disposed automatically when its owner panel
 * is disposed. It should not be disposed directly by user code.
 */
export interface IChildWidgetList extends IObservableList<Widget>, IDisposable {
    /**
     * The parent panel which owns the list.
     *
     * #### Notes
     * This is a read-only property.
     */
    parent: Panel;
}
/**
 * A widget which acts as a layout container for child widgets.
 *
 * #### Notes
 * This class typically serves as a base class for more concrete layout
 * panels, but can be used directly in combination with CSS to achieve
 * any desired layout for a collection of widgets.
 */
export declare class Panel extends Widget {
    /**
     * A singleton `'layout-request'` message.
     *
     * #### Notes
     * This message can be dispatched to supporting panels in order to
     * update their layout. Not all panels will respond to messages of
     * this type.
     *
     * This message is typically used to update the size constraints of
     * a panel and to update the position and size of its children.
     *
     * Messages of this type are compressed by default.
     *
     * **See also:** [[onLayoutRequest]]
     */
    static MsgLayoutRequest: Message;
    /**
     * Construct a new panel.
     */
    constructor();
    /**
     * Get the observable list of child widgets for the panel.
     *
     * #### Notes
     * This is a read-only property.
     */
    children: IChildWidgetList;
    /**
     * Process a message sent to the panel.
     *
     * @param msg - The message sent to the panel.
     *
     * #### Notes
     * Subclasses may reimplement this method as needed.
     */
    processMessage(msg: Message): void;
    /**
     * Compress a message posted to the panel.
     *
     * @param msg - The message posted to the panel.
     *
     * @param pending - The queue of pending messages for the panel.
     *
     * @returns `true` if the message was compressed and should be
     *   dropped, or `false` if the message should be enqueued for
     *   delivery as normal.
     *
     * #### Notes
     * This compresses `'layout-request'` messages in addition to the
     * compression provided by the base `Widget` class.
     *
     * Subclasses may reimplement this method as needed.
     */
    compressMessage(msg: Message, pending: Queue<Message>): boolean;
    /**
     * A message handler invoked on a `'child-added'` message.
     *
     * #### Notes
     * The default implementation adds the child node to the panel node
     * at the proper location and sends an `'after-attach'` message to
     * the child if the panel is attached to the DOM.
     *
     * Subclasses may reimplement this method to control how the child
     * node is added to the panel node, but a reimplementation must send
     * an `'after-attach'` message to the child if the panel is attached
     * to the DOM.
     */
    protected onChildAdded(msg: ChildMessage): void;
    /**
     * A message handler invoked on a `'child-moved'` message.
     *
     * #### Notes
     * The default implementation moves the child node to the proper
     * location in the panel node and sends both `'before-detach'` and
     * `'after-attach'` message to the child if the panel is attached
     * to the DOM.
     *
     * Subclasses may reimplement this method to control how the child
     * node is moved in the panel node, but a reimplementation must send
     * both `'before-detach'` and `'after-attach'` message to the child
     * if the panel is attached to the DOM.
     */
    protected onChildMoved(msg: ChildMessage): void;
    /**
     * A message handler invoked on a `'child-removed'` message.
     *
     * #### Notes
     * The default implementation removes the child node from the panel
     * node and sends a `'before-detach'` message to the child if the
     * panel is attached to the DOM.
     *
     * Subclasses may reimplement this method to control how the child
     * node is removed from the panel node, but a reimplementation must
     * send a `'before-detach'` message to the child if the panel is
     * attached to the DOM.
     */
    protected onChildRemoved(msg: ChildMessage): void;
    /**
     * A message handler invoked on a `'resize'` message.
     *
     * #### Notes
     * The default implementation of this handler sends an [[UnknownSize]]
     * resize message to each child. This ensures that the resize messages
     * propagate through all widgets in the hierarchy.
     *
     * Subclasses may reimplement this method as needed, but they must
     * dispatch `'resize'` messages to their children as appropriate.
     */
    protected onResize(msg: ResizeMessage): void;
    /**
     * A message handler invoked on an `'update-request'` message.
     *
     * #### Notes
     * The default implementation of this handler sends an [[UnknownSize]]
     * resize message to each child. This ensures that the all widgets in
     * the hierarchy remain correctly sized on updates.
     *
     * Subclasses may reimplement this method as needed, but they should
     * dispatch `'resize'` messages to their children if appropriate.
     */
    protected onUpdateRequest(msg: Message): void;
    /**
     * A message handler invoked on an `'after-show'` message.
     *
     * #### Notes
     * The default implementation of this handler forwards the message
     * to all of its non-hidden children.
     *
     * Subclasses may reimplement this method as needed, but they should
     * either call the superclass implementation or forward the message
     * to their non-hidden children as appropriate.
     */
    protected onAfterShow(msg: Message): void;
    /**
     * A message handler invoked on a `'before-hide'` message.
     *
     * #### Notes
     * The default implementation of this handler forwards the message
     * to all of its non-hidden children.
     *
     * Subclasses may reimplement this method as needed, but they should
     * either call the superclass implementation or forward the message
     * to their children as appropriate.
     */
    protected onBeforeHide(msg: Message): void;
    /**
     * A message handler invoked on an `'after-attach'` message.
     *
     * #### Notes
     * The default implementation of this handler forwards the message
     * to all of its children.
     *
     * Subclasses may reimplement this method as needed, but they should
     * either call the superclass implementation or forward the message
     * to their children as appropriate.
     */
    protected onAfterAttach(msg: Message): void;
    /**
     * A message handler invoked on a `'before-detach'` message.
     *
     * #### Notes
     * The default implementation of this handler forwards the message
     * to all of its children.
     *
     * Subclasses may reimplement this method as needed, but they should
     * either call the superclass implementation or forward the message
     * to their children as appropriate.
     */
    protected onBeforeDetach(msg: Message): void;
    /**
     * A message handler invoked on a `'layout-request'` message.
     *
     * The default implementation of this handler is a no-op.
     */
    protected onLayoutRequest(msg: Message): void;
    /**
     * A message handler invoked on a `'child-shown'` message.
     *
     * The default implementation of this handler is a no-op.
     */
    protected onChildShown(msg: ChildMessage): void;
    /**
     * A message handler invoked on a `'child-hidden'` message.
     *
     * The default implementation of this handler is a no-op.
     */
    protected onChildHidden(msg: ChildMessage): void;
    private _children;
}
