{
  "name": "phosphor-properties",
  "version": "2.0.0",
  "description": "A module for attached property descriptors.",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "dependencies": {
    "phosphor-signaling": "^1.1.2"
  },
  "devDependencies": {
    "coveralls": "^2.11.4",
    "expect.js": "^0.3.1",
    "istanbul": "^0.3.19",
    "mocha": "^2.2.5",
    "rimraf": "^2.4.2",
    "typedoc": "^0.3.11",
    "typescript": "^1.6.2"
  },
  "scripts": {
    "clean": "rimraf lib && rimraf test/build && rimraf test/coverage",
    "build:src": "tsc --project src",
    "build:test": "tsc --project test/src",
    "build": "npm run build:src && npm run build:test",
    "docs": "rimraf docs/api && typedoc --options scripts/tdoptions.json",
    "prepublish": "npm run build",
    "test": "mocha test/build/index.js",
    "test:coverage": "istanbul cover --dir test/coverage node_modules/mocha/bin/_mocha -- test/build/index.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/phosphorjs/phosphor-properties.git"
  },
  "files": [
    "lib/index.js",
    "lib/index.d.ts"
  ],
  "keywords": [
    "attached",
    "property",
    "properties"
  ],
  "author": {
    "name": "S. Chris Colbert",
    "email": "sccolbert@gmail.com"
  },
  "license": "BSD-3-Clause",
  "bugs": {
    "url": "https://github.com/phosphorjs/phosphor-properties/issues"
  },
  "homepage": "https://github.com/phosphorjs/phosphor-properties",
  "readme": "phosphor-properties\r\n===================\r\n\r\n[![Build Status](https://travis-ci.org/phosphorjs/phosphor-properties.svg)](https://travis-ci.org/phosphorjs/phosphor-properties?branch=master)\r\n[![Coverage Status](https://coveralls.io/repos/phosphorjs/phosphor-properties/badge.svg?branch=master&service=github)](https://coveralls.io/github/phosphorjs/phosphor-properties?branch=master)\r\n\r\nA module for attached property descriptors.\r\n\r\n[API Docs](http://phosphorjs.github.io/phosphor-properties/api/)\r\n\r\nPhosphor properties encapsulate several behaviors:\r\n\r\n  - **Creation** - A property value can default to a static scalar\r\n    value or be lazily created by invoking a value factory function.\r\n\r\n  - **Coercion** - A property can coerce a user-provided value into\r\n    a value which is guaranteed to be correct based on current state.\r\n\r\n  - **Notification** - User code can be notified when a property\r\n    value changes.\r\n\r\n  - **Attachment** - A property can be defined for *any* object, not\r\n    just for instances of the class which defines the property. This\r\n    allows for extra state and behavior to be \"attached\" to arbitrary\r\n    objects by external consumers of those objects.\r\n\r\nThese behavioral patterns are extremely useful for managing complexity in\r\nlarge applications. However, they are tedious and repetitive to implement\r\nmanually. Phosphor properties reduce developer burden by bundling these\r\nbehaviors into an efficient and type-safe form.\r\n\r\nPackage Install\r\n---------------\r\n\r\n**Prerequisites**\r\n- [node](http://nodejs.org/)\r\n\r\n```bash\r\nnpm install --save phosphor-properties\r\n```\r\n\r\n\r\nSource Build\r\n------------\r\n\r\n**Prerequisites**\r\n- [git](http://git-scm.com/)\r\n- [node](http://nodejs.org/)\r\n\r\n```bash\r\ngit clone https://github.com/phosphorjs/phosphor-properties.git\r\ncd phosphor-properties\r\nnpm install\r\n```\r\n\r\n**Rebuild**\r\n```bash\r\nnpm run clean\r\nnpm run build\r\n```\r\n\r\n\r\nRun Tests\r\n---------\r\n\r\nFollow the source build instructions first.\r\n\r\n```bash\r\nnpm test\r\n```\r\n\r\n\r\nBuild Docs\r\n----------\r\n\r\nFollow the source build instructions first.\r\n\r\n```bash\r\nnpm run docs\r\n```\r\n\r\nNavigate to `docs/index.html`.\r\n\r\n\r\nSupported Runtimes\r\n------------------\r\n\r\nThe runtime versions which are currently *known to work* are listed below.\r\nEarlier versions may also work, but come with no guarantees.\r\n\r\n- Node 0.12.7+\r\n- IE 11+\r\n- Firefox 32+\r\n- Chrome 38+\r\n\r\n\r\nBundle for the Browser\r\n----------------------\r\n\r\nFollow the package install instructions first.\r\n\r\n```bash\r\nnpm install --save-dev browserify\r\nbrowserify myapp.js -o mybundle.js\r\n```\r\n\r\n\r\nUsage Examples\r\n--------------\r\n\r\n**Note:** This module is fully compatible with Node/Babel/ES6/ES5. Simply\r\nomit the type declarations when using a language other than TypeScript.\r\n\r\nClass authors should strive to maintain consistency in how their classes\r\nexpose properties to consumers. The PhosphorJS project has adopted a set\r\nof conventions which cover property naming, behavior, and exposure. It is\r\nrecommended for third party libraries to adopt these same conventions in\r\norder to ensure API consistency and maximal compatibility with libraries\r\nand meta tools which rely on these conventions.\r\n\r\nWhen defining a property for use by instances of the **same** class:\r\n\r\n  - Define the property as a static member of the class.\r\n\r\n  - Ensure the class type is used as the property owner type.\r\n\r\n  - Append the suffix `'Property'` to the static member name.\r\n\r\n  - Give the property a `name` which is the same as the static\r\n    member name, minus the `'Property'` suffix.\r\n\r\n  - Define a public getter/setter which delegates access to the\r\n    static property. The getter/setter should contain no logic\r\n    outside of delegation to the static property.\r\n\r\n  - The name of the getter/setter should be the same as the `name`\r\n    given to the property.\r\n\r\n  - Consumers should normally use the getter/setter to access the\r\n    property, but meta tools and code generators are free to use\r\n    the property API directly. This is why the getter/setter must\r\n    be a pure delegate as described above.\r\n\r\nWhen defining a property for use by instances of a **different** class:\r\n\r\n  - Define the property as a static member of the class.\r\n\r\n  - Ensure the instance type is used as the property owner type.\r\n\r\n  - Append the suffix `'Property'` to the static member name.\r\n\r\n  - Give the property a `name` which is the same as the static\r\n    member name, minus the `'Property'` suffix.\r\n\r\n  - Define static methods to get and set the value of the property\r\n    for a particular instance of the owner type. These two methods\r\n    should contain no logic outside of delegation to the static\r\n    property.\r\n\r\n  - Name the static methods by prepending `'get'` and `'set'` to\r\n    the capitalized property `name`.\r\n\r\n  - Consumers should normally use the static methods to access the\r\n    property, but meta tools and code generators are free to use\r\n    the property API directly. This is why the methods must be\r\n    pure delegates as described above.\r\n\r\nA property declared for instances of a different class is referred to as\r\nan *attached property*. The behavior and semantics of the property are\r\ndefined by one class, but the property value belongs to a foreign instance.\r\nThis pattern is useful when creating container objects which must associate\r\ncontainer data with child objects in a way which doesn't require polluting\r\nthe child class with extraneous data members.\r\n\r\n**Basic Value:**\r\n\r\n```typescript\r\nimport {\r\n  Property\r\n} from 'phosphor-properties';\r\n\r\n\r\nclass MyObject {\r\n\r\n  static valueProperty = new Property<MyObject, number>({\r\n    name: 'value',\r\n    value: 42,\r\n  });\r\n\r\n  get value(): number {\r\n    return MyObject.valueProperty.get(this);\r\n  }\r\n\r\n  set value(value: number) {\r\n    MyObject.valueProperty.set(this, value);\r\n  }\r\n}\r\n\r\n\r\nlet obj = new MyObject();\r\n\r\nobj.value;       // 42\r\nobj.value = 17;  //\r\nobj.value;       // 17\r\n```\r\n\r\n**Create Callback:**\r\n\r\n```typescript\r\nimport {\r\n  Property\r\n} from 'phosphor-properties';\r\n\r\n\r\nclass MyObject {\r\n\r\n  static oneProperty = new Property<MyObject, number[]>({\r\n    name: 'one',\r\n    value: [1, 2, 3],\r\n  });\r\n\r\n  static twoProperty = new Property<MyObject, number[]>({\r\n    name: 'two',\r\n    create: () => [1, 2, 3],\r\n  });\r\n\r\n  get one(): number[] {\r\n    return MyObject.oneProperty.get(this);\r\n  }\r\n\r\n  get two(): number[] {\r\n    return MyObject.twoProperty.get(this);\r\n  }\r\n}\r\n\r\n\r\nlet obj1 = new MyObject();\r\nlet obj2 = new MyObject();\r\n\r\nobj1.one;               // [1, 2, 3]\r\nobj1.two;               // [1, 2, 3]\r\n\r\nobj2.one;               // [1, 2, 3]\r\nobj2.two;               // [1, 2, 3]\r\n\r\nobj1.one === obj2.one;  // true\r\nobj1.two === obj2.two;  // false\r\n```\r\n\r\n**Changed Callback:**\r\n\r\n```typescript\r\nimport {\r\n  Property\r\n} from 'phosphor-properties';\r\n\r\n\r\nclass MyObject {\r\n\r\n  static valueProperty = new Property<MyObject, number>({\r\n    name: 'value',\r\n    value: 42,\r\n    changed: (owner, old, value) => { owner._onValueChanged(old, value); },\r\n  });\r\n\r\n  get value(): number {\r\n    return MyObject.valueProperty.get(this);\r\n  }\r\n\r\n  set value(value: number) {\r\n    MyObject.valueProperty.set(this, value);\r\n  }\r\n\r\n  private _onValueChanged(old, value): void {\r\n    console.log(`value changed: ${old}, ${value}`);\r\n  }\r\n}\r\n\r\n\r\nlet obj = new MyObject();\r\n\r\nobj.value;       // 42\r\nobj.value = 17;  // logs: value changed: 42, 17\r\nobj.value;       // 17\r\n```\r\n\r\n**Coerce Callback:**\r\n\r\n```typescript\r\nimport {\r\n  Property\r\n} from 'phosphor-properties';\r\n\r\n\r\nclass MyObject {\r\n\r\n  static checkableProperty = new Property<MyObject, boolean>({\r\n    name: 'checkable',\r\n    value: true,\r\n    changed: owner => { MyObject.checkedProperty.coerce(owner); },\r\n  });\r\n\r\n  static checkedProperty = new Property<MyObject, boolean>({\r\n    name: 'checked',\r\n    value: false,\r\n    coerce: (owner, value) => owner.checkable ? value : false,\r\n  });\r\n\r\n  get checkable(): boolean {\r\n    return MyObject.checkableProperty.get(this);\r\n  }\r\n\r\n  set checkable(value: boolean) {\r\n    MyObject.checkableProperty.set(this, value);\r\n  }\r\n\r\n  get checked(): boolean {\r\n    return MyObject.checkedProperty.get(this);\r\n  }\r\n\r\n  set checked(value: boolean) {\r\n    MyObject.checkedProperty.set(this, value);\r\n  }\r\n}\r\n\r\n\r\nlet obj = new MyObject();\r\n\r\nobj.checkable;          // true\r\nobj.checked;            // false\r\n\r\nobj.checked = true;     //\r\nobj.checked;            // true\r\n\r\nobj.checkable = false;  //\r\nobj.checked;            // false\r\n```\r\n\r\n**Notify Signal:**\r\n\r\n```typescript\r\nimport {\r\n  IChangedArgs, Property\r\n} from 'phosphor-properties';\r\n\r\nimport {\r\n  ISignal, Signal\r\n} from 'phosphor-signaling';\r\n\r\n\r\nclass MyObject {\r\n\r\n  static stateChangedSignal = new Signal<MyObject, IChangedArgs<any>>();\r\n\r\n  static valueProperty = new Property<MyObject, number>({\r\n    name: 'value',\r\n    value: 42,\r\n    notify: MyObject.stateChangedSignal,\r\n  });\r\n\r\n  static nameProperty = new Property<MyObject, string>({\r\n    name: 'name',\r\n    value: 'John',\r\n    notify: MyObject.stateChangedSignal,\r\n  });\r\n\r\n  get stateChanged(): ISignal<MyObject, IChangedArgs<any>> {\r\n    return MyObject.stateChangedSignal.bind(this);\r\n  }\r\n\r\n  get value(): number {\r\n    return MyObject.valueProperty.get(this);\r\n  }\r\n\r\n  set value(value: number) {\r\n    MyObject.valueProperty.set(this, value);\r\n  }\r\n\r\n  get name(): number {\r\n    return MyObject.nameProperty.get(this);\r\n  }\r\n\r\n  set name(value: number) {\r\n    MyObject.nameProperty.set(this, value);\r\n  }\r\n}\r\n\r\n\r\nfunction logger(sender: MyObject, args: IChangedArgs<any>): void {\r\n  console.log(`name: ${args.name}, old: ${args.oldValue}, new: ${args.newValue}`);\r\n}\r\n\r\n\r\nlet obj = new MyObject();\r\n\r\nobj.stateChanged.connect(logger);\r\n\r\nobj.value = 17;     // logs: name: 'value', old: 42, new: 17\r\nobj.name = 'Jane';  // logs: name: 'name', old: 'John', new: 'Jane'\r\n```\r\n\r\n**Compare Callback:**\r\n\r\n```typescript\r\nimport {\r\n  Property\r\n} from 'phosphor-properties';\r\n\r\n\r\nclass MyObject {\r\n\r\n  static oneProperty = new Property<MyObject, number>({\r\n    name: 'one',\r\n    value: 42,\r\n    changed: () => { console.log('one changed'); },\r\n  });\r\n\r\n  static twoProperty = new Property<MyObject, number>({\r\n    name: 'two',\r\n    value: 19,\r\n    compare: (a, b) => true,\r\n    changed: () => { console.log('two changed'); },\r\n  });\r\n\r\n  static threeProperty = new Property<MyObject, number>({\r\n    name: 'three',\r\n    value: 100,\r\n    compare: (a, b) => false,\r\n    changed: () => { console.log('three changed'); },\r\n  });\r\n\r\n  get one(): number {\r\n    return MyObject.oneProperty.get(this);\r\n  }\r\n\r\n  set one(value: number) {\r\n    MyObject.oneProperty.set(this, value);\r\n  }\r\n\r\n  get two(): number {\r\n    return MyObject.twoProperty.get(this);\r\n  }\r\n\r\n  set two(value: number) {\r\n    MyObject.twoProperty.set(this, value);\r\n  }\r\n\r\n  get three(): number {\r\n    return MyObject.threeProperty.get(this);\r\n  }\r\n\r\n  set three(value: number) {\r\n    MyObject.threeProperty.set(this, value);\r\n  }\r\n}\r\n\r\n\r\nlet obj = new MyObject();\r\n\r\nobj.one;        // 42\r\nobj.two;        // 19\r\nobj.three;      // 100\r\n\r\nobj.one = 0;    // logs: one changed\r\nobj.one;        // 0\r\nobj.one = 1;    // logs: one changed\r\nobj.one;        // 1\r\nobj.one = 1;    // no log\r\nobj.one;        // 1\r\n\r\nobj.two = 0;    // no log\r\nobj.two;        // 0\r\nobj.two = 1;    // no log\r\nobj.two;        // 1\r\nobj.two = 1;    // no log\r\nobj.two;        // 1\r\n\r\nobj.three = 0;  // logs: three changed\r\nobj.three;      // 0\r\nobj.three = 1;  // logs: three changed\r\nobj.three;      // 1\r\nobj.three = 1;  // logs: three changed\r\nobj.three;      // 1\r\n```\r\n\r\n**Attached Property:**\r\n\r\n```typescript\r\nimport {\r\n  Property\r\n} from 'phosphor-properties';\r\n\r\n\r\nclass MyWidget {\r\n  // ...\r\n}\r\n\r\n\r\nclass MyContainer {\r\n\r\n  static stretchProperty = new Property<MyWidget, number>({\r\n    name: 'stretch',\r\n    value: 0,\r\n    coerce: (owner, value) => Math.max(0, value),\r\n  });\r\n\r\n  static getStretch(widget: MyWidget): number {\r\n    return MyContainer.stretchProperty.get(widget);\r\n  }\r\n\r\n  static setStretch(widget: MyWidget, value: number): void {\r\n    MyContainer.stretchProperty.set(widget, value);\r\n  }\r\n\r\n  addWidget(widget: MyWidget): void {\r\n    let stretch = MyContainer.getStretch(widget);\r\n    // ...\r\n  }\r\n}\r\n\r\n\r\nlet widget = new MyWidget();\r\nMyContainer.setStretch(widget, 3);\r\n\r\nlet container = new MyContainer();\r\ncontainer.addWidget(widget);\r\n```\r\n",
  "readmeFilename": "README.md",
  "gitHead": "6a3a9938bea7d8f1cbaac32a3bde4b6426064de6",
  "_id": "phosphor-properties@2.0.0",
  "_shasum": "fae2ff80370e6dd40dc696ca7c512403d16956ec",
  "_from": "phosphor-properties@2.0.0"
}
